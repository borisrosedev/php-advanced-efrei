<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"><title>J3 : Optimisation des performances</title><link rel="stylesheet" href="node_modules/reveal.js/dist/reset.css"><link rel="stylesheet" href="node_modules/reveal.js/dist/reveal.css"><link rel="stylesheet" href="node_modules/reveal.js/dist/theme/black.css" id="theme"><!--This CSS is generated by the Asciidoctor reveal.js converter to further integrate AsciiDoc's existing semantic with reveal.js--><style type="text/css">.reveal div.right {
  float: right
}

/* source blocks */
.reveal .listingblock.stretch > .content {
  height: 100%
}

.reveal .listingblock.stretch > .content > pre {
  height: 100%
}

.reveal .listingblock.stretch > .content > pre > code {
  height: 100%;
  max-height: 100%
}

/* auto-animate feature */
/* hide the scrollbar when auto-animating source blocks */
.reveal pre[data-auto-animate-target] {
  overflow: hidden;
}

.reveal pre[data-auto-animate-target] code {
  overflow: hidden;
}

/* add a min width to avoid horizontal shift on line numbers */
code.hljs .hljs-ln-line.hljs-ln-n {
  min-width: 1.25em;
}

/* tables */
table {
  border-collapse: collapse;
  border-spacing: 0
}

table {
  margin-bottom: 1.25em;
  border: solid 1px #dedede
}

table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td {
  padding: .5em .625em .625em;
  font-size: inherit;
  text-align: left
}

table tr th, table tr td {
  padding: .5625em .625em;
  font-size: inherit
}

table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td {
  display: table-cell;
  line-height: 1.6
}

td.tableblock > .content {
  margin-bottom: 1.25em
}

td.tableblock > .content > :last-child {
  margin-bottom: -1.25em
}

table.tableblock, th.tableblock, td.tableblock {
  border: 0 solid #dedede
}

table.grid-all > thead > tr > .tableblock, table.grid-all > tbody > tr > .tableblock {
  border-width: 0 1px 1px 0
}

table.grid-all > tfoot > tr > .tableblock {
  border-width: 1px 1px 0 0
}

table.grid-cols > * > tr > .tableblock {
  border-width: 0 1px 0 0
}

table.grid-rows > thead > tr > .tableblock, table.grid-rows > tbody > tr > .tableblock {
  border-width: 0 0 1px
}

table.grid-rows > tfoot > tr > .tableblock {
  border-width: 1px 0 0
}

table.grid-all > * > tr > .tableblock:last-child, table.grid-cols > * > tr > .tableblock:last-child {
  border-right-width: 0
}

table.grid-all > tbody > tr:last-child > .tableblock, table.grid-all > thead:last-child > tr > .tableblock, table.grid-rows > tbody > tr:last-child > .tableblock, table.grid-rows > thead:last-child > tr > .tableblock {
  border-bottom-width: 0
}

table.frame-all {
  border-width: 1px
}

table.frame-sides {
  border-width: 0 1px
}

table.frame-topbot, table.frame-ends {
  border-width: 1px 0
}

.reveal table th.halign-left, .reveal table td.halign-left {
  text-align: left
}

.reveal table th.halign-right, .reveal table td.halign-right {
  text-align: right
}

.reveal table th.halign-center, .reveal table td.halign-center {
  text-align: center
}

.reveal table th.valign-top, .reveal table td.valign-top {
  vertical-align: top
}

.reveal table th.valign-bottom, .reveal table td.valign-bottom {
  vertical-align: bottom
}

.reveal table th.valign-middle, .reveal table td.valign-middle {
  vertical-align: middle
}

table thead th, table tfoot th {
  font-weight: bold
}

tbody tr th {
  display: table-cell;
  line-height: 1.6
}

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p {
  font-weight: bold
}

thead {
  display: table-header-group
}

.reveal table.grid-none th, .reveal table.grid-none td {
  border-bottom: 0 !important
}

/* kbd macro */
kbd {
  font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace;
  display: inline-block;
  color: rgba(0, 0, 0, .8);
  font-size: .65em;
  line-height: 1.45;
  background: #f7f7f7;
  border: 1px solid #ccc;
  -webkit-border-radius: 3px;
  border-radius: 3px;
  -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, .2), 0 0 0 .1em white inset;
  box-shadow: 0 1px 0 rgba(0, 0, 0, .2), 0 0 0 .1em #fff inset;
  margin: 0 .15em;
  padding: .2em .5em;
  vertical-align: middle;
  position: relative;
  top: -.1em;
  white-space: nowrap
}

.keyseq kbd:first-child {
  margin-left: 0
}

.keyseq kbd:last-child {
  margin-right: 0
}

/* callouts */
.conum[data-value] {
  display: inline-block;
  color: #fff !important;
  background: rgba(0, 0, 0, .8);
  -webkit-border-radius: 50%;
  border-radius: 50%;
  text-align: center;
  font-size: .75em;
  width: 1.67em;
  height: 1.67em;
  line-height: 1.67em;
  font-family: "Open Sans", "DejaVu Sans", sans-serif;
  font-style: normal;
  font-weight: bold
}

.conum[data-value] * {
  color: #fff !important
}

.conum[data-value] + b {
  display: none
}

.conum[data-value]:after {
  content: attr(data-value)
}

pre .conum[data-value] {
  position: relative;
  top: -.125em
}

b.conum * {
  color: inherit !important
}

.conum:not([data-value]):empty {
  display: none
}

/* Callout list */
.hdlist > table, .colist > table {
  border: 0;
  background: none
}

.hdlist > table > tbody > tr, .colist > table > tbody > tr {
  background: none
}

td.hdlist1, td.hdlist2 {
  vertical-align: top;
  padding: 0 .625em
}

td.hdlist1 {
  font-weight: bold;
  padding-bottom: 1.25em
}

/* Disabled from Asciidoctor CSS because it caused callout list to go under the
 * source listing when .stretch is applied (see #335)
 * .literalblock+.colist,.listingblock+.colist{margin-top:-.5em} */
.colist td:not([class]):first-child {
  padding: .4em .75em 0;
  line-height: 1;
  vertical-align: top
}

.colist td:not([class]):first-child img {
  max-width: none
}

.colist td:not([class]):last-child {
  padding: .25em 0
}

/* Override Asciidoctor CSS that causes issues with reveal.js features */
.reveal .hljs table {
  border: 0
}

/* Callout list rows would have a bottom border with some reveal.js themes (see #335) */
.reveal .colist > table th, .reveal .colist > table td {
  border-bottom: 0
}

/* Fixes line height with Highlight.js source listing when linenums enabled (see #331) */
.reveal .hljs table thead tr th, .reveal .hljs table tfoot tr th, .reveal .hljs table tbody tr td, .reveal .hljs table tr td, .reveal .hljs table tfoot tr td {
  line-height: inherit
}

/* Columns layout */
.columns .slide-content {
  display: flex;
}

.columns.wrap .slide-content {
  flex-wrap: wrap;
}

.columns.is-vcentered .slide-content {
  align-items: center;
}

.columns .slide-content > .column {
  display: block;
  flex-basis: 0;
  flex-grow: 1;
  flex-shrink: 1;
}

.columns .slide-content > .column > * {
  padding: .75rem;
}

/* See #353 */
.columns.wrap .slide-content > .column {
  flex-basis: auto;
}

.columns .slide-content > .column.is-full {
  flex: none;
  width: 100%;
}

.columns .slide-content > .column.is-four-fifths {
  flex: none;
  width: 80%;
}

.columns .slide-content > .column.is-three-quarters {
  flex: none;
  width: 75%;
}

.columns .slide-content > .column.is-two-thirds {
  flex: none;
  width: 66.6666%;
}

.columns .slide-content > .column.is-three-fifths {
  flex: none;
  width: 60%;
}

.columns .slide-content > .column.is-half {
  flex: none;
  width: 50%;
}

.columns .slide-content > .column.is-two-fifths {
  flex: none;
  width: 40%;
}

.columns .slide-content > .column.is-one-third {
  flex: none;
  width: 33.3333%;
}

.columns .slide-content > .column.is-one-quarter {
  flex: none;
  width: 25%;
}

.columns .slide-content > .column.is-one-fifth {
  flex: none;
  width: 20%;
}

.columns .slide-content > .column.has-text-left {
  text-align: left;
}

.columns .slide-content > .column.has-text-justified {
  text-align: justify;
}

.columns .slide-content > .column.has-text-right {
  text-align: right;
}

.columns .slide-content > .column.has-text-left {
  text-align: left;
}

.columns .slide-content > .column.has-text-justified {
  text-align: justify;
}

.columns .slide-content > .column.has-text-right {
  text-align: right;
}

.text-left {
  text-align: left !important
}

.text-right {
  text-align: right !important
}

.text-center {
  text-align: center !important
}

.text-justify {
  text-align: justify !important
}

.footnotes {
  border-top: 1px solid rgba(0, 0, 0, 0.2);
  padding: 0.5em 0 0 0;
  font-size: 0.65em;
  margin-top: 4em;
}

.byline {
  font-size:.8em
}
ul.byline {
  list-style-type: none;
}
ul.byline li + li {
  margin-top: 0.25em;
}
</style></head><body><div class="reveal"><div class="slides"><section><section id="_j3_optimisation_des_performances"><h2>J3 : Optimisation des performances</h2></section><section id="_profilage_et_benchmarking_du_code_php"><h2>Profilage et benchmarking du code PHP</h2><div class="slide-content"><div class="paragraph"><p>Le profilage et le benchmarking sont des techniques essentielles pour mesurer la performance d&#8217;une application PHP.</p></div></div></section><section id=""><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Ils permettent:</p></div>
<div class="ulist ùstep"><ul class="ùstep"><li><p>d&#8217;identifier les goulots d&#8217;étranglement,</p></li><li><p>de comprendre où le temps de traitement est passé</p></li><li><p>d&#8217;optimiser l&#8217;application pour la rendre plus rapide et efficace.</p></li></ul></div></div></section><section id="_profilage"><h2>Profilage :</h2><div class="slide-content"><div class="paragraph"><p>Processus d&#8217;analyse en profondeur d&#8217;un programme pour comprendre où les ressources (CPU, mémoire, etc.) sont consommées.</p></div>
<div class="paragraph"><p>Il permet de mesurer la performance de chaque fonction ou section de code.</p></div></div></section><section id="_benchmarking"><h2>Benchmarking :</h2><div class="slide-content"><div class="paragraph"><p>Mesurer le temps d&#8217;exécution d&#8217;une ou plusieurs portions de code pour comparer différentes implémentations ou évaluer les performances globales.</p></div></div></section></section>
<section><section id="_benchmarking_en_php"><h2>Benchmarking en PHP</h2><div class="slide-content"><div class="paragraph"><p>Le benchmarking consiste à mesurer le temps que prend une certaine portion de code à s&#8217;exécuter.</p></div></div></section><section id="_2"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Cela peut être utile pour comparer plusieurs solutions pour un même problème, ou tout simplement pour identifier des sections de code lentes.</p></div></div></section><section id="_utilisation_de_microtime_pour_le_benchmarking"><h2>Utilisation de microtime() pour le benchmarking</h2><div class="slide-content"><div class="paragraph"><p>La fonction microtime(true) permet d&#8217;obtenir le timestamp actuel en microsecondes, ce qui est utile pour mesurer des temps d&#8217;exécution très courts avec une bonne précision.</p></div></div></section><section id="_exemple"><h2>Exemple:</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-php" data-lang="php">// Démarrer le chronomètre
$start_time = microtime(true);

// Section de code à profiler
for ($i = 0; $i &lt; 1000000; $i++) {
    $a = $i * $i;
}

// Arrêter le chronomètre
$end_time = microtime(true);

// Calculer le temps écoulé
$execution_time = $end_time - $start_time;

echo "Temps d'exécution : " . $execution_time . " secondes";</code></pre></div></div></div></section></section>
<section><section id="_explication"><h2>Explication :</h2></section><section id="_microtimetrue"><h2>microtime(true) :</h2><div class="slide-content"><div class="paragraph"><p>Renvoie l&#8217;heure actuelle avec une précision à la microseconde.</p></div></div></section><section id="_3"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Le temps écoulé est calculé en soustrayant le timestamp de début de celui de fin.</p></div></div></section><section id="_4"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Le temps d&#8217;exécution est ensuite affiché en secondes.</p></div></div></section><section id="_mesurer_la_mémoire_consommée"><h2>Mesurer la mémoire consommée</h2><div class="slide-content"><div class="paragraph"><p>En plus du temps d&#8217;exécution, il est parfois utile de savoir combien de mémoire une section de code consomme. PHP fournit la fonction memory_get_usage() pour obtenir la mémoire utilisée par le script en octets.</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-php" data-lang="php">// Démarrer le benchmarking de la mémoire
$start_memory = memory_get_usage();

// Section de code à profiler
$array = [];
for ($i = 0; $i &lt; 100000; $i++) {
    $array[] = $i * $i;
}

// Mesurer la mémoire après l'exécution
$end_memory = memory_get_usage();
$memory_used = $end_memory - $start_memory;

echo "Mémoire utilisée : " . $memory_used . " octets";</code></pre></div></div></div></section><section id="_explication_2"><h2>Explication :</h2><div class="slide-content"><div class="paragraph"><p>memory_get_usage() renvoie la quantité de mémoire utilisée par le script en cours d&#8217;exécution.</p></div></div></section><section id="_5"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Le différentiel avant et après le code permet de connaître la mémoire consommée par cette portion de code spécifique.</p></div></div></section></section>
<section><section id="_profilage_du_code_php"><h2>Profilage du code PHP</h2><div class="slide-content"><div class="paragraph"><p>Le profilage permet d&#8217;avoir une vue plus détaillée de la performance de chaque partie du code.</p></div></div></section><section id="_6"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Le but est d&#8217;identifier les parties les plus coûteuses en termes de temps ou de ressources.</p></div></div></section><section id="_7"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Il existe plusieurs outils pour profiler du code PHP, chacun ayant des fonctionnalités différentes.</p></div></div></section></section>
<section><section id="_outils_de_profilage_populaires"><h2>Outils de profilage populaires</h2></section><section id="_xdebug"><h2>Xdebug</h2><div class="slide-content"><div class="paragraph"><p>Xdebug est l&#8217;un des outils de profilage les plus populaires en PHP.</p></div></div></section><section id="_8"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Il permet de profiler un script PHP en générant un fichier de profilage (fichier cachegrind) que vous pouvez analyser avec des outils comme KCacheGrind ou QCacheGrind.</p></div></div></section><section id="_installation_de_xdebug"><h2>Installation de Xdebug :</h2><div class="slide-content"><div class="paragraph"><p>Pour installer Xdebug, vous pouvez généralement utiliser votre gestionnaire de paquets (par exemple, apt ou yum) ou télécharger directement l&#8217;extension.</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-bash" data-lang="bash"># Installation de Xdebug sur Debian/Ubuntu
sudo apt install php-xdebug
# Installation de Xdebug sur Mac
pecl install xdebug</code></pre></div></div></div></section><section id="_configuration_de_xdebug_pour_le_profilage"><h2>Configuration de Xdebug pour le profilage :</h2><div class="slide-content"><div class="paragraph"><p>Une fois Xdebug installé, vous devez l&#8217;activer et le configurer pour le profilage dans le fichier php.ini :</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-ini" data-lang="ini">[xdebug]
zend_extension=xdebug.so
xdebug.mode=profile
xdebug.output_dir="/chemin/vers/le/dossier/profilage"
xdebug.profiler_output_name = "cachegrind.out.%p"</code></pre></div></div></div></section><section id="_xdebug_modeprofile"><h2>xdebug.mode=profile :</h2><div class="slide-content"><div class="paragraph"><p>Active le mode profilage de Xdebug.</p></div></div></section><section id="_xdebug_output_dir"><h2>xdebug.output_dir :</h2><div class="slide-content"><div class="paragraph"><p>Spécifie le dossier où les fichiers de profilage seront enregistrés.
xdebug.profiler_output_name : Définit le format du nom de fichier de sortie.</p></div></div></section><section id="_utilisation"><h2>Utilisation :</h2><div class="slide-content"><div class="paragraph"><p>Une fois activé, Xdebug générera un fichier de profilage (cachegrind.out.&lt;pid&gt;) chaque fois que vous exécutez un script PHP. Ce fichier peut ensuite être analysé avec des outils comme KCacheGrind ou QCacheGrind pour visualiser les fonctions les plus coûteuses.</p></div></div></section></section>
<section><section id="_blackfire"><h2>Blackfire</h2><div class="slide-content"><div class="paragraph"><p>Blackfire est un autre outil de profilage performant qui est largement utilisé pour profiler les applications PHP.</p></div></div></section><section id="_9"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Contrairement à Xdebug, Blackfire est un service SaaS avec une intégration dans des environnements de production pour un impact minimal.</p></div></div></section><section id="_installation_de_blackfire"><h2>Installation de Blackfire :</h2><div class="slide-content"><div class="paragraph"><p>Vous pouvez installer l&#8217;agent Blackfire et l&#8217;extension PHP Blackfire en suivant les instructions disponibles sur blackfire.io.</p></div></div></section><section id="_utilisation_2"><h2>Utilisation :</h2><div class="slide-content"><div class="paragraph"><p>Une fois installé, vous pouvez profiler votre code PHP à l&#8217;aide de la ligne de commande Blackfire ou de son interface web.</p></div></div></section><section id="_10"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Il fournit des graphiques visuels interactifs montrant les fonctions les plus coûteuses, les requêtes de base de données lentes, etc.</p></div></div></section></section>
<section><section id="_tideways"><h2>Tideways</h2><div class="slide-content"><div class="paragraph"><p>Tideways est un autre outil de profilage et de surveillance pour PHP.</p></div></div></section><section id="_11"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Il permet de surveiller les performances des applications en production avec un impact minimal sur les performances.</p></div></div></section><section id="_12"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Comme Blackfire, il s&#8217;agit d&#8217;une solution payante, mais elle propose des fonctionnalités avancées de surveillance des performances en temps réel.</p></div></div></section><section id="_comparaison_de_plusieurs_portions_de_code"><h2>Comparaison de plusieurs portions de code</h2><div class="slide-content"><div class="paragraph"><p>Vous pouvez utiliser des outils de benchmarking pour comparer les performances de différentes implémentations d&#8217;une même fonctionnalité.</p></div></div></section><section id="_13"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Par exemple, vous souhaitez comparer la vitesse d&#8217;exécution de deux façons différentes de parcourir un tableau.</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-php" data-lang="php">// Première méthode : boucle foreach
$start_time = microtime(true);
$array = range(1, 100000);
foreach ($array as $value) {
    $result = $value * $value;
}
$end_time = microtime(true);
echo "Temps foreach : " . ($end_time - $start_time) . " secondes&lt;br&gt;";

// Deuxième méthode : boucle for
$start_time = microtime(true);
for ($i = 0; $i &lt; count($array); $i++) {
    $result = $array[$i] * $array[$i];
}
$end_time = microtime(true);
echo "Temps for : " . ($end_time - $start_time) . " secondes&lt;br&gt;";</code></pre></div></div></div></section></section>
<section><section id="_profiling_en_environnement_de_production"><h2>Profiling en environnement de production</h2><div class="slide-content"><div class="paragraph"><p>Le profilage en production est délicat car il peut ajouter une surcharge importante à l&#8217;application.</p></div></div></section><section id="_14"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Pour minimiser cet impact, vous pouvez utiliser des outils comme Blackfire ou Tideways, qui sont conçus pour être utilisés en production avec une surcharge minimale.</p></div></div></section></section>
<section><section id="_bonnes_pratiques_pour_le_profilage_en_production"><h2>Bonnes pratiques pour le profilage en production :</h2></section><section id="_limiter_le_nombre_de_profils"><h2>Limiter le nombre de profils :</h2><div class="slide-content"><div class="paragraph"><p>Ne pas profiler chaque requête, mais seulement un échantillon pour éviter de ralentir l&#8217;application.</p></div></div></section><section id="_effectuer_des_tests_en_période_de_faible_affluence"><h2>Effectuer des tests en période de faible affluence :</h2><div class="slide-content"><div class="paragraph"><p>Essayez de profiler l&#8217;application pendant des périodes où le trafic est faible pour minimiser l&#8217;impact sur les utilisateurs.</p></div></div></section><section id="_utiliser_un_outil_conçu_pour_la_production"><h2>Utiliser un outil conçu pour la production :</h2><div class="slide-content"><div class="paragraph"><p>Des outils comme Tideways et Blackfire sont conçus pour être utilisés en production sans affecter les performances.</p></div></div></section><section id="_optimisation_du_code_après_le_profilage"><h2>Optimisation du code après le profilage</h2><div class="slide-content"><div class="paragraph"><p>Le but du profilage est d&#8217;identifier les parties du code qui consomment le plus de ressources.</p></div></div></section></section>
<section><section id="_quelques_techniques_doptimisation_que_vous_pouvez_appliquer_après_avoir_identifié_les_problèmes"><h2>Quelques techniques d&#8217;optimisation que vous pouvez appliquer après avoir identifié les problèmes :</h2></section><section id="_réduction_des_appels_de_fonctions_coûteuses"><h2>Réduction des appels de fonctions coûteuses :</h2><div class="slide-content"><div class="paragraph"><p>Si une fonction est appelée de manière répétée, voyez s&#8217;il est possible de la calculer une seule fois.</p></div></div></section><section id="_amélioration_des_requêtes_sql"><h2>Amélioration des requêtes SQL :</h2><div class="slide-content"><div class="paragraph"><p>Si des requêtes SQL lentes sont identifiées, optimisez-les avec des index, en réduisant la complexité des jointures, etc.</p></div></div></section><section id="_utilisation_du_cache"><h2>Utilisation du cache :</h2><div class="slide-content"><div class="paragraph"><p>Si des calculs ou des requêtes sont réutilisés fréquemment, vous pouvez mettre en cache leurs résultats.</p></div></div></section><section id="_réduction_de_lutilisation_de_la_mémoire"><h2>Réduction de l&#8217;utilisation de la mémoire :</h2><div class="slide-content"><div class="paragraph"><p>Si un profil montre que votre application consomme trop de mémoire, essayez de libérer les ressources inutiles ou d&#8217;utiliser des structures de données plus économes en mémoire.</p></div></div></section><section id="_utilisation_de_xdebug_et_autres_outils_de_profilage"><h2>Utilisation de Xdebug et autres outils de profilage</h2><div class="slide-content"><div class="paragraph"><p>Le profilage en PHP est une technique utilisée pour analyser en détail le comportement d&#8217;une application, en identifiant les parties du code qui consomment le plus de ressources ou de temps d&#8217;exécution.</p></div></div></section><section id="_15"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Cela permet de repérer les goulots d&#8217;étranglement et d&#8217;optimiser les performances. Parmi les outils de profilage les plus populaires pour PHP, Xdebug est largement utilisé. Cependant, il existe d&#8217;autres outils tels que Blackfire et Tideways.</p></div></div></section></section>
<section><section id="_utilisation_de_xdebug_pour_le_profilage"><h2>Utilisation de Xdebug pour le profilage</h2><div class="slide-content"><div class="paragraph"><p>Xdebug est un outil polyvalent pour le développement PHP, offrant des fonctionnalités de débogage, de traçage, et de profilage.</p></div></div></section><section id="_16"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Il est souvent utilisé pour générer des rapports de profilage détaillés, qui peuvent être analysés à l&#8217;aide d&#8217;outils comme KCacheGrind ou QCacheGrind.</p></div></div></section></section>
<section id="_installation_de_xdebug_2"><h2>Installation de Xdebug</h2><div class="slide-content"><div class="paragraph"><p>La méthode d&#8217;installation dépend de votre environnement. Sur les distributions Linux telles que Debian/Ubuntu, vous pouvez installer Xdebug via les paquets :</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-bash" data-lang="bash">sudo apt-get install php-xdebug</code></pre></div></div>
<div class="paragraph"><p>Sur d&#8217;autres systèmes, vous pouvez utiliser PECL :</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-bash" data-lang="bash">pecl install xdebug</code></pre></div></div></div></section>
<section><section id="_configuration_de_xdebug_pour_le_profilage_2"><h2>Configuration de Xdebug pour le profilage</h2><div class="slide-content"><div class="paragraph"><p>Une fois Xdebug installé, il faut le configurer pour activer le mode de profilage. Cela se fait en modifiant votre fichier php.ini ou un fichier de configuration spécifique à Xdebug.</p></div></div></section><section id="_exemple_de_configuration_pour_activer_le_profilage_avec_xdebug"><h2>Exemple de configuration pour activer le profilage avec Xdebug :</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-php" data-lang="php">[xdebug]
zend_extension=xdebug.so
xdebug.mode=profile
xdebug.profiler_output_dir="/chemin/vers/dossier/profilage"  ; Dossier où les fichiers de profilage seront sauvegardés
xdebug.profiler_output_name = "cachegrind.out.%p"           ; Nom du fichier de sortie (avec %p pour le PID du processus)
xdebug.profiler_enable = 1                                  ; Activer le profilage par défaut pour chaque requête</code></pre></div></div></div></section><section id="_xdebug_profiler_output_dir"><h2>xdebug.profiler_output_dir :</h2><div class="slide-content"><div class="paragraph"><p>Spécifie le dossier où les fichiers de profilage seront enregistrés. Assurez-vous que le serveur web a les permissions d&#8217;écriture sur ce dossier.</p></div></div></section><section id="_xdebug_profiler_output_name"><h2>xdebug.profiler_output_name :</h2><div class="slide-content"><div class="paragraph"><p>Permet de personnaliser le nom des fichiers de profilage. %p représente l&#8217;ID du processus PHP, ce qui permet d&#8217;avoir un fichier unique par exécution.</p></div></div></section><section id="_xdebug_profiler_enable_1"><h2>xdebug.profiler_enable = 1 :</h2><div class="slide-content"><div class="paragraph"><p>Active le profilage pour toutes les requêtes PHP. Vous pouvez désactiver cette option et l&#8217;activer ponctuellement avec des triggers pour réduire la surcharge en production.</p></div></div></section></section>
<section><section id="_exécution_et_collecte_des_fichiers_de_profilage"><h2>Exécution et collecte des fichiers de profilage</h2><div class="slide-content"><div class="paragraph"><p>Lorsque Xdebug est configuré et activé, chaque exécution de script PHP génère un fichier de sortie de profilage (généralement au format cachegrind).</p></div></div></section><section id="_17"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Par exemple, une exécution sur un script pourrait générer un fichier nommé cachegrind.out.12345.</p></div></div></section><section id="_18"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Ces fichiers peuvent ensuite être analysés à l&#8217;aide de KCacheGrind ou QCacheGrind.</p></div></div></section></section>
<section><section id="_analyse_des_fichiers_de_profilage_avec_kcachegrindqcachegrind"><h2>Analyse des fichiers de profilage avec KCacheGrind/QCacheGrind</h2><div class="slide-content"><div class="paragraph"><p>KCacheGrind et QCacheGrind sont des outils visuels qui permettent de charger les fichiers de profilage générés par Xdebug.</p></div></div></section><section id="_19"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Ils fournissent des informations détaillées sur les fonctions les plus coûteuses (en temps et en ressources), les appels de fonction, et d&#8217;autres métriques.</p></div></div></section><section id="_20"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>KCacheGrind est disponible sous Linux via les gestionnaires de paquets (apt install kcachegrind).</p></div></div></section><section id="_21"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>QCacheGrind est une version pour Windows et macOS.</p></div></div></section></section>
<section><section id="_pour_utiliser_ces_outils"><h2>Pour utiliser ces outils :</h2><div class="slide-content"><div class="paragraph"><p>Ouvrez KCacheGrind ou QCacheGrind.</p></div></div></section><section id="_22"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Chargez le fichier cachegrind.out.&lt;pid&gt; généré par Xdebug.</p></div></div></section><section id="_23"><h2>&#8230;&#8203;</h2></section><section id="_analysez_les_données_visuellement"><h2>Analysez les données visuellement :</h2><div class="slide-content"><div class="paragraph"><p>Les fonctions les plus coûteuses (triées par temps d&#8217;exécution ou utilisation mémoire).</p></div></div></section><section id="_24"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Les appels de fonction imbriqués.</p></div></div></section><section id="_25"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Les chemins d&#8217;exécution.</p></div></div></section><section id="_26"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Les ressources consommées par chaque fonction.</p></div></div></section></section>
<section><section id="_activer_le_profilage_de_manière_sélective_avec_des_triggers"><h2>Activer le profilage de manière sélective avec des triggers</h2><div class="slide-content"><div class="paragraph"><p>Il n&#8217;est pas recommandé d&#8217;activer le profilage pour toutes les requêtes en production à cause de la surcharge induite.</p></div></div></section><section id="_27"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Xdebug propose des triggers pour activer ponctuellement le profilage via un cookie, une variable GET/POST, ou une variable d&#8217;environnement.</p></div></div></section><section id="_28"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Par exemple, vous pouvez configurer Xdebug pour activer le profilage seulement si un certain cookie est défini :</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-ini" data-lang="ini">xdebug.profiler_enable_trigger = 1
xdebug.profiler_enable_trigger_value = "profiling_enabled"</code></pre></div></div></div></section><section id="_29"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Dans ce cas, le profilage ne sera activé que si la requête contient le cookie profiling_enabled=true.</p></div></div></section></section>
<section><section id="_utilisation_de_blackfire_pour_le_profilage"><h2>Utilisation de Blackfire pour le profilage</h2><div class="slide-content"><div class="paragraph"><p>Blackfire est un outil avancé de profilage et d&#8217;analyse des performances pour PHP, conçu pour fonctionner dans des environnements de développement et de production avec un faible impact sur les performances.</p></div></div></section><section id="_30"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Il permet de capturer des profils de performance détaillés, d&#8217;analyser les points faibles d&#8217;une application, et de suivre l&#8217;évolution des performances au fil du temps.</p></div></div></section></section>
<section id="_installation_de_blackfire_2"><h2>Installation de Blackfire</h2></section>
<section><section id="_blackfire_se_compose_de_plusieurs_composants"><h2>Blackfire se compose de plusieurs composants :</h2></section><section id="_lextension_php_blackfire"><h2>L&#8217;extension PHP Blackfire :</h2><div class="slide-content"><div class="paragraph"><p>Capture les informations de profilage.</p></div></div></section><section id="_lagent_blackfire"><h2>L&#8217;agent Blackfire :</h2><div class="slide-content"><div class="paragraph"><p>Communique avec le serveur Blackfire pour envoyer les données de profilage.</p></div></div></section><section id="_31"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>L&#8217;installation est bien documentée sur le site officiel de Blackfire. Voici un aperçu de l&#8217;installation sous Linux :</p></div></div></section><section id="_installation_de_lagent_blackfire"><h2>Installation de l&#8217;agent Blackfire :</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-bash" data-lang="bash">wget -O - https://packages.blackfire.io/gpg.key | sudo apt-key add -
echo "deb http://packages.blackfire.io/debian any main" | sudo tee /etc/apt/sources.list.d/blackfire.list
sudo apt-get update
sudo apt-get install blackfire-agent</code></pre></div></div></div></section></section>
<section id="_installation_de_lextension_php_blackfire"><h2>Installation de l&#8217;extension PHP Blackfire :</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-bash" data-lang="bash">sudo apt-get install blackfire-php</code></pre></div></div></div></section>
<section><section id="_configuration_des_identifiants_de_lagent"><h2>Configuration des identifiants de l&#8217;agent :</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-bash" data-lang="bash">blackfire-agent --register</code></pre></div></div></div></section><section id="_profilage_avec_blackfire"><h2>Profilage avec Blackfire</h2><div class="slide-content"><div class="paragraph"><p>Une fois installé, vous pouvez déclencher des profils manuellement à l&#8217;aide de la ligne de commande Blackfire CLI ou à partir de l&#8217;interface web.</p></div></div></section><section id="_32"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Blackfire génère des rapports détaillés sur les appels de fonction, les requêtes SQL, les E/S réseau, etc.</p></div></div></section><section id="_utilisation_de_blackfire_en_ligne_de_commande"><h2>Utilisation de Blackfire en ligne de commande :</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-bash" data-lang="bash">blackfire run php script.php</code></pre></div></div></div></section><section id="_profilage_dune_url"><h2>Profilage d&#8217;une URL :</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-bash" data-lang="bash">blackfire curl http://localhost/mon-boris-script.php</code></pre></div></div></div></section><section id="_33"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Les résultats de chaque profil sont disponibles via l&#8217;interface web de Blackfire, où vous pouvez:</p></div>
<div class="ulist"><ul><li class="fragment"><p>visualiser les temps d&#8217;exécution,</p></li><li class="fragment"><p>les fonctions coûteuses,</p></li><li class="fragment"><p>obtenir des suggestions d&#8217;optimisation.</p></li></ul></div></div></section></section>
<section><section id="_utilisation_de_tideways_pour_le_profilage_et_la_surveillance"><h2>Utilisation de Tideways pour le profilage et la surveillance</h2><div class="slide-content"><div class="paragraph"><p>Tideways est un autre outil de profilage et de surveillance des performances pour PHP. Contrairement à Xdebug, qui est plus orienté développement, Tideways est conçu pour surveiller les applications PHP en production avec un impact minimal.</p></div></div></section><section id="_34"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Il fournit des informations en temps réel sur les performances de l&#8217;application, y compris des analyses des requêtes lentes, des erreurs et des alertes.</p></div></div></section><section id="_installation_de_tideways"><h2>Installation de Tideways</h2><div class="slide-content"><div class="paragraph"><p>Tideways s&#8217;installe en tant qu&#8217;extension PHP. Les instructions complètes sont disponibles sur tideways.com.</p></div></div></section><section id="_installation_de_lextension"><h2>Installation de l&#8217;extension :</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-php" data-lang="php">sudo apt-get install tideways-php</code></pre></div></div></div></section><section id="_configuration_de_lapi_key_dans_php_ini"><h2>Configuration de l&#8217;API Key dans php.ini :</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-ini" data-lang="ini">extension=tideways.so
tideways.api_key="your_api_key"</code></pre></div></div>
<div class="paragraph"><p>Redémarrer le serveur PHP pour appliquer la configuration.</p></div></div></section></section>
<section><section id="_utilisation_de_tideways"><h2>Utilisation de Tideways</h2><div class="slide-content"><div class="paragraph"><p>Tideways capture des profils de performance de manière continue en production.</p></div></div></section><section id="_35"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Il offre une interface web qui permet d&#8217;analyser en temps réel les performances des requêtes, des appels de fonction et des requêtes SQL.</p></div></div></section><section id="_36"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Il fournit également des graphiques et des alertes en cas de ralentissement.</p></div></div></section><section id="_optimisation_des_requêtes_sql_dans_php"><h2>Optimisation des requêtes SQL dans PHP</h2><div class="slide-content"><div class="paragraph"><p>L&#8217;optimisation des requêtes SQL est une étape essentielle dans le développement d&#8217;applications PHP qui interagissent avec des bases de données, car des requêtes inefficaces peuvent ralentir considérablement une application.</p></div></div></section><section id="_37"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Une bonne optimisation des requêtes SQL permet d&#8217;améliorer la performance globale, de réduire les temps de chargement, et de diminuer l&#8217;utilisation des ressources.</p></div></div></section></section>
<section><section id="_stratégies_et_des_techniques_pour_optimiser_les_requêtes_sql_dans_une_application_php"><h2>Stratégies et des techniques pour optimiser les requêtes SQL dans une application PHP :</h2></section><section id="_utilisation_dindex"><h2>Utilisation d&#8217;index</h2><div class="slide-content"><div class="paragraph"><p>Les index permettent à la base de données de retrouver plus rapidement les lignes dans une table, en fonction des colonnes indexées.</p></div></div></section><section id="_38"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>L&#8217;absence d&#8217;index sur les colonnes régulièrement interrogées peut entraîner des recherches séquentielles lentes (full table scan).</p></div></div></section><section id="_comment_utiliser_les_index"><h2>Comment utiliser les index :</h2><div class="slide-content"><div class="paragraph"><p>Créer un index sur les colonnes fréquemment utilisées dans les requêtes WHERE, ORDER BY, GROUP BY :</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-sql" data-lang="sql">CREATE INDEX idx_nom_utilisateur ON utilisateurs(nom);</code></pre></div></div></div></section><section id="_utiliser_des_index_pour_les_clés_étrangères"><h2>Utiliser des index pour les clés étrangères :</h2><div class="slide-content"><div class="paragraph"><p>Les colonnes qui sont des clés étrangères et qui participent à des jointures fréquentes doivent être indexées :</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-sql" data-lang="sql">CREATE INDEX idx_utilisateur_id ON commandes(utilisateur_id);</code></pre></div></div></div></section><section id="_index_sur_plusieurs_colonnes_index_composite"><h2>Index sur plusieurs colonnes (index composite) :</h2><div class="slide-content"><div class="paragraph"><p>Si une requête filtre ou trie sur plusieurs colonnes, un index composite peut améliorer les performances :</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-sql" data-lang="sql">CREATE INDEX idx_nom_prenom ON utilisateurs(nom, prenom);</code></pre></div></div></div></section><section id="_exemple_en_php"><h2>Exemple en PHP :</h2><div class="slide-content"><div class="paragraph"><p>Lorsque vous interrogez une table sur des colonnes indexées, vous obtenez des résultats beaucoup plus rapidement.</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-php" data-lang="php">// Requête optimisée en fonction d'un index sur 'nom'
$query = $pdo-&gt;prepare("SELECT * FROM utilisateurs WHERE nom = :nom");
$query-&gt;execute(['nom' =&gt; 'Doe']);</code></pre></div></div></div></section></section>
<section><section id="_utilisation_de_requêtes_préparées"><h2>Utilisation de requêtes préparées</h2><div class="slide-content"><div class="paragraph"><p>L&#8217;utilisation des requêtes préparées améliore la sécurité (prévention des injections SQL).</p></div></div></section><section id="_39"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Elle permet également de réutiliser la même requête plusieurs fois avec des valeurs différentes, optimisant ainsi la communication avec la base de données.</p></div></div></section><section id="_exemple_en_php_avec_pdo"><h2>Exemple en PHP avec PDO :</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-php" data-lang="php">$pdo = new PDO('mysql:host=localhost;dbname=test', 'root', '');

// Préparer la requête
$query = $pdo-&gt;prepare("SELECT * FROM utilisateurs WHERE nom = :nom");

// Exécuter plusieurs fois avec des paramètres différents
$query-&gt;execute(['nom' =&gt; 'Doe']);
$utilisateurs = $query-&gt;fetchAll();

$query-&gt;execute(['nom' =&gt; 'Smith']);
$autres_utilisateurs = $query-&gt;fetchAll();</code></pre></div></div></div></section><section id="_40"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Avec les requêtes préparées, la requête SQL est compilée une seule fois, et les paramètres sont envoyés séparément, ce qui réduit le temps de compilation des requêtes répétitives.</p></div></div></section></section>
<section><section id="_limiter_les_résultats_avec_limit"><h2>Limiter les résultats avec LIMIT</h2><div class="slide-content"><div class="paragraph"><p>Lorsque vous récupérez des données depuis une base de données, limitez les résultats au strict nécessaire à l&#8217;aide de la clause LIMIT.</p></div></div></section><section id="_41"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Cela est particulièrement important pour les grands ensembles de données, car récupérer toutes les lignes d&#8217;une table peut être coûteux.</p></div></div></section><section id="_exemple_2"><h2>Exemple :</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-php" data-lang="php">$query = $pdo-&gt;query("SELECT * FROM utilisateurs ORDER BY date_inscription DESC LIMIT 10");</code></pre></div></div></div></section><section id="_42"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Cela permet de réduire le nombre de lignes renvoyées et améliore les performances, surtout si vous affichez des résultats paginés (comme dans les systèmes de gestion de contenu ou de catalogue de produits).</p></div></div></section></section>
<section><section id="_sélectionner_uniquement_les_colonnes_nécessaires_select"><h2>Sélectionner uniquement les colonnes nécessaires (SELECT)</h2><div class="slide-content"><div class="paragraph"><p>Il est courant de voir des requêtes qui utilisent SELECT * pour récupérer toutes les colonnes d&#8217;une table.</p></div></div></section><section id="_43"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Cependant, cette pratique peut être inefficace, surtout si vous n&#8217;avez besoin que de quelques colonnes.</p></div></div></section><section id="_exemple_3"><h2>Exemple :</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-php" data-lang="php">// Mauvaise pratique : SELECT * récupère toutes les colonnes
$query = $pdo-&gt;query("SELECT * FROM utilisateurs");

// Bonne pratique : sélectionner uniquement les colonnes nécessaires
$query = $pdo-&gt;query("SELECT nom, prenom, email FROM utilisateurs");</code></pre></div></div></div></section><section id="_44"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>En sélectionnant uniquement les colonnes dont vous avez réellement besoin, vous réduisez la quantité de données transférées et améliorez les performances globales.</p></div></div></section></section>
<section><section id="_éviter_les_requêtes_n1"><h2>Éviter les requêtes N+1</h2><div class="slide-content"><div class="paragraph"><p>Le problème des requêtes N+1 survient lorsque, pour chaque ligne d&#8217;une requête, vous exécutez une nouvelle requête pour récupérer des données supplémentaires, créant ainsi une surcharge importante en nombre de requêtes SQL.</p></div></div></section><section id="_exemple_de_requête_n1"><h2>Exemple de requête N+1 :</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-php" data-lang="php">// Récupération des utilisateurs
$utilisateurs = $pdo-&gt;query("SELECT * FROM utilisateurs")-&gt;fetchAll();

// Pour chaque utilisateur, une nouvelle requête pour récupérer ses commandes
foreach ($utilisateurs as $utilisateur) {
    $commandes = $pdo-&gt;query("SELECT * FROM commandes WHERE utilisateur_id = " . $utilisateur['id'])-&gt;fetchAll();
}</code></pre></div></div></div></section><section id="_45"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Cela génère une requête pour chaque utilisateur, ce qui peut entraîner des centaines ou des milliers de requêtes si la base de données contient beaucoup d&#8217;enregistrements.</p></div></div></section><section id="_solution"><h2>Solution :</h2><div class="slide-content"><div class="paragraph"><p>utiliser des jointures ou une requête plus efficace :</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-php" data-lang="php">// Utiliser une jointure pour récupérer les utilisateurs et leurs commandes en une seule requête
$query = $pdo-&gt;query("
    SELECT u.nom, c.*
    FROM utilisateurs u
    LEFT JOIN commandes c ON u.id = c.utilisateur_id
");</code></pre></div></div></div></section><section id="_46"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Avec cette approche, vous réduisez considérablement le nombre de requêtes exécutées et améliorez la performance globale.</p></div></div></section></section>
<section><section id="_utilisation_de_caches"><h2>Utilisation de caches</h2></section><section id="_cache_de_requêtes_sql"><h2>Cache de requêtes SQL</h2><div class="slide-content"><div class="paragraph"><p>Pour les requêtes fréquemment exécutées, comme celles qui récupèrent des résultats statiques (par exemple, une liste de catégories ou de produits), il est judicieux d&#8217;utiliser un cache. Cela évite de réexécuter les mêmes requêtes SQL à chaque demande.</p></div></div></section><section id="_47"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Des systèmes comme Redis ou Memcached peuvent être utilisés pour stocker le résultat d&#8217;une requête SQL coûteuse dans un cache.</p></div></div></section><section id="_exemple_4"><h2>Exemple :</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-php" data-lang="php">$cacheKey = "categories_liste";
$categories = $cache-&gt;get($cacheKey);

if (!$categories) {
    $query = $pdo-&gt;query("SELECT * FROM categories");
    $categories = $query-&gt;fetchAll();
    $cache-&gt;set($cacheKey, $categories, 3600); // Cache pendant 1 heure
}</code></pre></div></div></div></section></section>
<section><section id="_optimiser_les_requêtes_avec_des_jointures_join"><h2>Optimiser les requêtes avec des jointures (JOIN)</h2><div class="slide-content"><div class="paragraph"><p>Les jointures permettent de relier plusieurs tables et d&#8217;exécuter une requête en une seule fois.</p></div></div></section><section id="_48"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Cependant, il est important d&#8217;optimiser l&#8217;utilisation des JOIN, surtout lorsqu&#8217;il s&#8217;agit de grandes tables.</p></div></div></section><section id="_49"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Privilégier les jointures simples (INNER JOIN) quand cela est possible.</p></div></div></section><section id="_50"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>S&#8217;assurer que les colonnes sur lesquelles vous effectuez des jointures sont indexées.</p></div></div></section><section id="_exemple_5"><h2>Exemple :</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-sql" data-lang="sql">SELECT utilisateurs.nom, commandes.total
FROM utilisateurs
INNER JOIN commandes ON utilisateurs.id = commandes.utilisateur_id
WHERE commandes.date &gt; '2023-01-01';</code></pre></div></div></div></section><section id="_51"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Cela permet de récupérer les données des utilisateurs et leurs commandes récentes en une seule requête.</p></div></div></section></section>
<section><section id="_utilisation_des_explain_pour_analyser_les_requêtes"><h2>Utilisation des EXPLAIN pour analyser les requêtes</h2><div class="slide-content"><div class="paragraph"><p>Utiliser EXPLAIN vous permet de comprendre comment MySQL ou un autre moteur de base de données exécute une requête.</p></div></div></section><section id="_52"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Cela vous donne des informations sur l&#8217;ordre des jointures, les index utilisés, les scans de table, et d&#8217;autres aspects de la performance.</p></div></div></section><section id="_exemple_6"><h2>Exemple :</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-sql" data-lang="sql">EXPLAIN SELECT * FROM utilisateurs WHERE nom = 'Doe';</code></pre></div></div></div></section><section id="_53"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>EXPLAIN affiche un plan d&#8217;exécution qui vous indique comment la base de données traite la requête.</p></div></div></section><section id="_54"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Si vous remarquez des full table scans là où des index pourraient être utilisés, cela peut indiquer qu&#8217;un index manque.</p></div></div></section></section>
<section><section id="_regroupement_et_agrégation_optimisée_group_by_having_count"><h2>Regroupement et agrégation optimisée (GROUP BY, HAVING, COUNT)</h2><div class="slide-content"><div class="paragraph"><p>Lorsque vous utilisez des fonctions d&#8217;agrégation telles que COUNT, SUM, ou AVG, assurez-vous que les colonnes sur lesquelles vous regroupez sont bien indexées.</p></div></div></section><section id="_exemple_doptimisation_avec_count"><h2>Exemple d&#8217;optimisation avec COUNT() :</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-php" data-lang="php">// Mauvaise pratique : Compter toutes les lignes sans optimisation
$query = $pdo-&gt;query("SELECT COUNT(*) FROM utilisateurs WHERE statut = 'actif'");

// Bonne pratique : Utiliser un index partiel si possible
$query = $pdo-&gt;query("SELECT COUNT(*) FROM utilisateurs WHERE statut = 'actif' AND date_inscription &gt; '2023-01-01'");</code></pre></div></div></div></section></section>
<section><section id="_réduction_des_appels_à_la_base_de_données"><h2>Réduction des appels à la base de données</h2><div class="slide-content"><div class="paragraph"><p>Enfin, essayez de minimiser le nombre de requêtes SQL exécutées.</p></div></div></section><section id="_55"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Si vous devez récupérer de nombreuses informations liées, regroupez-les autant que possible dans une seule requête, ou utilisez un cache pour éviter les requêtes répétitives.</p></div></div></section></section>
<section><section id="_caching_des_résultats_opcache_memcached_redis"><h2>Caching des résultats (OPcache, Memcached, Redis)</h2><div class="slide-content"><div class="paragraph"><p>Le caching est une technique importante en développement web, notamment en PHP, pour améliorer les performances en réduisant le temps d&#8217;exécution des scripts et en minimisant les accès aux bases de données.</p></div></div></section><section id="_56"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Différentes méthodes de caching, notamment:</p></div>
<div class="ulist"><ul><li class="fragment"><p>OPcache,</p></li><li class="fragment"><p>Memcached,</p></li><li class="fragment"><p>Redis</p></li></ul></div></div></section></section>
<section><section id="_opcache"><h2>OPcache</h2><div class="slide-content"><div class="paragraph"><p>OPcache est une extension PHP intégrée qui optimise les performances en mettant en cache le bytecode PHP compilé dans la mémoire.</p></div></div></section><section id="_57"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Cela permet d&#8217;éviter la recompilation des scripts PHP à chaque requête.</p></div></div></section><section id="_fonctionnement"><h2>Fonctionnement :</h2><div class="slide-content"><div class="paragraph"><p>OPcache garde en mémoire le bytecode des scripts PHP.</p></div></div></section><section id="_58"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Lorsqu&#8217;une requête arrive, PHP n&#8217;a pas besoin de recompiler le script, mais utilise directement la version déjà compilée en mémoire.</p></div></div></section><section id="_avantages"><h2>Avantages :</h2><div class="slide-content"><div class="paragraph"><p>Réduction du temps de chargement des scripts.</p></div>
<div class="paragraph"><p>Facile à configurer, car intégré à PHP.</p></div></div></section><section id="_cas_dusage"><h2>Cas d&#8217;usage :</h2><div class="slide-content"><div class="paragraph"><p>Optimisation du temps de réponse des applications web PHP sans effort de développement supplémentaire.</p></div></div></section><section id="_configuration_basique_php_ini"><h2>Configuration basique (php.ini) :</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-php" data-lang="php">opcache.enable=1
opcache.memory_consumption=128
opcache.max_accelerated_files=10000
opcache.revalidate_freq=60</code></pre></div></div></div></section></section>
<section><section id="_memcached"><h2>Memcached</h2><div class="slide-content"><div class="paragraph"><p>Memcached est un système de caching distribué conçu pour stocker des paires clé-valeur en mémoire, utilisé pour soulager la charge des bases de données.</p></div></div></section><section id="_fonctionnement_2"><h2>Fonctionnement :</h2><div class="slide-content"><div class="paragraph"><p>Il stocke les données en mémoire (RAM) sous forme de paires clé-valeur.</p></div></div></section><section id="_59"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Il est souvent utilisé pour mettre en cache des résultats de requêtes lourdes ou des sessions utilisateur.</p></div></div></section><section id="_avantages_2"><h2>Avantages :</h2><div class="slide-content"><div class="paragraph"><p>Très rapide pour lire des données.</p></div></div></section><section id="_60"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Distribué et scalable, idéal pour des environnements multi-serveurs.</p></div></div></section><section id="_cas_dusage_2"><h2>Cas d&#8217;usage :</h2><div class="slide-content"><div class="paragraph"><p>Caching de résultats de requêtes de base de données, stockage de sessions, ou d&#8217;autres données à accès rapide.</p></div></div></section><section id="_exemple_dutilisation_en_php"><h2>Exemple d&#8217;utilisation en PHP :</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-php" data-lang="php">$memcached = new Memcached();
$memcached-&gt;addServer("localhost", 11211);

// Stocker des données
$memcached-&gt;set("key", "value", 3600);

// Récupérer des données
$value = $memcached-&gt;get("key");</code></pre></div></div></div></section></section>
<section><section id="_redis"><h2>Redis</h2><div class="slide-content"><div class="paragraph"><p>Redis est une base de données clé-valeur en mémoire qui permet le stockage de données persistantes, contrairement à Memcached.</p></div></div></section><section id="_61"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Redis offre des fonctionnalités avancées comme la gestion des types de données complexes (listes, sets, hashes).</p></div></div></section><section id="_fonctionnement_3"><h2>Fonctionnement :</h2><div class="slide-content"><div class="paragraph"><p>Redis fonctionne également en RAM mais peut aussi écrire sur disque pour persister les données.</p></div></div></section><section id="_62"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Il est capable de gérer des types de données plus complexes, ce qui le rend plus polyvalent que Memcached.</p></div></div></section><section id="_avantages_3"><h2>Avantages :</h2><div class="slide-content"><div class="paragraph"><p>Supporte la persistance des données.</p></div></div></section><section id="_63"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Peut gérer des structures de données complexes.</p></div></div></section><section id="_64"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Permet la réplication et la haute disponibilité.</p></div></div></section><section id="_cas_dusage_3"><h2>Cas d&#8217;usage :</h2><div class="slide-content"><div class="ulist"><ul><li class="fragment"><p>Caching de sessions,</p></li><li class="fragment"><p>données persistantes,</p></li><li class="fragment"><p>file d&#8217;attente,</p></li><li class="fragment"><p>traitement en temps réel.</p></li></ul></div></div></section><section id="_exemple_dutilisation_en_php_2"><h2>Exemple d&#8217;utilisation en PHP :</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-php" data-lang="php">$redis = new Redis();
$redis-&gt;connect('127.0.0.1', 6379);

// Stocker une donnée
$redis-&gt;set("key", "value");

// Récupérer une donnée
$value = $redis-&gt;get("key");</code></pre></div></div></div></section></section>
<section><section id="_choisir_entre_memcached_et_redis"><h2>Choisir entre Memcached et Redis</h2><div class="slide-content"><div class="paragraph"><p>Memcached est plus simple et est généralement utilisé pour des scénarios où la rapidité est critique, et où la persistence des données n’est pas nécessaire.</p></div></div></section><section id="_65"><h2>&#8230;&#8203;</h2><div class="slide-content"><div class="paragraph"><p>Redis est plus puissant, avec des fonctionnalités avancées comme la persistance et le support de structures de données complexes.</p></div></div></section></section></div></div><script src="node_modules/reveal.js/dist/reveal.js"></script><script>Array.prototype.slice.call(document.querySelectorAll('.slides section')).forEach(function(slide) {
  if (slide.getAttribute('data-background-color')) return;
  // user needs to explicitly say he wants CSS color to override otherwise we might break custom css or theme (#226)
  if (!(slide.classList.contains('canvas') || slide.classList.contains('background'))) return;
  var bgColor = getComputedStyle(slide).backgroundColor;
  if (bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
    slide.setAttribute('data-background-color', bgColor);
    slide.style.backgroundColor = 'transparent';
  }
});

// More info about config & dependencies:
// - https://github.com/hakimel/reveal.js#configuration
// - https://github.com/hakimel/reveal.js#dependencies
Reveal.initialize({
  // Display presentation control arrows
  controls: true,
  // Help the user learn the controls by providing hints, for example by
  // bouncing the down arrow when they first encounter a vertical slide
  controlsTutorial: true,
  // Determines where controls appear, "edges" or "bottom-right"
  controlsLayout: 'bottom-right',
  // Visibility rule for backwards navigation arrows; "faded", "hidden"
  // or "visible"
  controlsBackArrows: 'faded',
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: false,
  // Control which views the slide number displays on
  showSlideNumber: 'all',
  // Add the current slide number to the URL hash so that reloading the
  // page/copying the URL will return you to the same slide
  hash: false,
  // Push each slide change to the browser history. Implies `hash: true`
  history: false,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Disables the default reveal.js slide layout so that you can use custom CSS layout
  disableLayout: false,
  // Vertical centering of slides
  center: true,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // See https://github.com/hakimel/reveal.js/#navigation-mode
  navigationMode: 'default',
  // Randomizes the order of slides each time the presentation loads
  shuffle: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags whether to include the current fragment in the URL,
  // so that reloading brings you to the same fragment position
  fragmentInURL: false,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Flags if we should show a help overlay when the questionmark
  // key is pressed
  help: true,
  // Flags if speaker notes should be visible to all viewers
  showNotes: false,
  // Global override for autolaying embedded media (video/audio/iframe)
  // - null: Media will only autoplay if data-autoplay is present
  // - true: All media will autoplay, regardless of individual setting
  // - false: No media will autoplay, regardless of individual setting
  autoPlayMedia: null,
  // Global override for preloading lazy-loaded iframes
  // - null: Iframes with data-src AND data-preload will be loaded when within
  //   the viewDistance, iframes with only data-src will be loaded when visible
  // - true: All iframes with data-src will be loaded when within the viewDistance
  // - false: All iframes with data-src will be loaded only when visible
  preloadIframes: null,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Use this method for navigation when auto-sliding
  autoSlideMethod: Reveal.navigateNext,
  // Specify the average time in seconds that you think you will spend
  // presenting each slide. This is used to show a pacing timer in the
  // speaker view
  defaultTiming: 120,
  // Specify the total time in seconds that is available to
  // present.  If this is set to a nonzero value, the pacing
  // timer will work out the time available for each slide,
  // instead of using the defaultTiming value
  totalTime: 0,
  // Specify the minimum amount of time you want to allot to
  // each slide, if using the totalTime calculation method.  If
  // the automated time allocation causes slide pacing to fall
  // below this threshold, then you will see an alert in the
  // speaker notes window
  minimumTimePerSlide: 0,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hide cursor if inactive
  hideInactiveCursor: true,
  // Time before the cursor is hidden (in ms)
  hideCursorTime: 5000,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  // Add `data-preview-link` and `data-preview-link="false"` to customise each link
  // individually
  previewLinks: false,
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: 'slide',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Number of slides away from the current that are visible on mobile
  // devices. It is advisable to set this to a lower number than
  // viewDistance in order to save resources.
  mobileViewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',
  // Number of pixels to move the parallax background per slide
  // - Calculated automatically unless specified
  // - Set to 0 to disable movement along an axis
  parallaxBackgroundHorizontal: null,
  parallaxBackgroundVertical: null,
  // The display mode that will be used to show slides
  display: 'block',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // PDF Export Options
  // Put each fragment on a separate page
  pdfSeparateFragments: true,
  // For slides that do not fit on a page, max number of pages
  pdfMaxPagesPerSlide: 1,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'node_modules/reveal.js/plugin/zoom/zoom.js', async: true, callback: function () { Reveal.registerPlugin(RevealZoom) } },
      { src: 'node_modules/reveal.js/plugin/notes/notes.js', async: true, callback: function () { Reveal.registerPlugin(RevealNotes) } }
  ],
});</script><script>var dom = {};
dom.slides = document.querySelector('.reveal .slides');

function getRemainingHeight(element, slideElement, height) {
  height = height || 0;
  if (element) {
    var newHeight, oldHeight = element.style.height;
    // Change the .stretch element height to 0 in order find the height of all
    // the other elements
    element.style.height = '0px';
    // In Overview mode, the parent (.slide) height is set of 700px.
    // Restore it temporarily to its natural height.
    slideElement.style.height = 'auto';
    newHeight = height - slideElement.offsetHeight;
    // Restore the old height, just in case
    element.style.height = oldHeight + 'px';
    // Clear the parent (.slide) height. .removeProperty works in IE9+
    slideElement.style.removeProperty('height');
    return newHeight;
  }
  return height;
}

function layoutSlideContents(width, height) {
  // Handle sizing of elements with the 'stretch' class
  toArray(dom.slides.querySelectorAll('section .stretch')).forEach(function (element) {
    // Determine how much vertical space we can use
    var limit = 5; // hard limit
    var parent = element.parentNode;
    while (parent.nodeName !== 'SECTION' && limit > 0) {
      parent = parent.parentNode;
      limit--;
    }
    if (limit === 0) {
      // unable to find parent, aborting!
      return;
    }
    var remainingHeight = getRemainingHeight(element, parent, height);
    // Consider the aspect ratio of media elements
    if (/(img|video)/gi.test(element.nodeName)) {
      var nw = element.naturalWidth || element.videoWidth, nh = element.naturalHeight || element.videoHeight;
      var es = Math.min(width / nw, remainingHeight / nh);
      element.style.width = (nw * es) + 'px';
      element.style.height = (nh * es) + 'px';
    } else {
      element.style.width = width + 'px';
      element.style.height = remainingHeight + 'px';
    }
  });
}

function toArray(o) {
  return Array.prototype.slice.call(o);
}

Reveal.addEventListener('slidechanged', function () {
  layoutSlideContents(960, 700)
});
Reveal.addEventListener('ready', function () {
  layoutSlideContents(960, 700)
});
Reveal.addEventListener('resize', function () {
  layoutSlideContents(960, 700)
});</script></body></html>