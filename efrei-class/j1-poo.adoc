= Jour 1 : POO
:revealjs_theme: beige
:source-highlighter: highlight.js
:icons: font


Révision des concepts fondamentaux et avancés de PHP

== Objectifs de la session :

Revoir les concepts clés du développement PHP procédural et orienté objet.

=== ...

Appréhender les techniques avancées pour structurer et améliorer la qualité du code.

=== ...

Comprendre comment implémenter des design patterns classiques en PHP.

//-----------------------------------------------------------------------

== Classe et objet : 

Explication des concepts de base, en soulignant les bonnes pratiques pour l'initialisation des objets.

=== ...

L'initialisation des objets est une étape fondamentale en programmation orientée objet (POO) car elle permet de créer des instances d'une classe avec des valeurs initiales spécifiques. 

== Concepts de base :

== Classe et Objet :

=== Classe : 

Une classe est un modèle ou un plan à partir duquel des objets sont créés. 

Elle définit les attributs (propriétés) et les comportements (méthodes) d'un objet.


=== Objet : 

Un objet est une instance d'une classe. 

=== ...

Lorsqu'un objet est créé, il contient les données définies par les propriétés et peut exécuter les actions définies par les méthodes de la classe.


=== Exemple basique d'une classe et d'un objet en PHP :

[source, php]
----
class Car {
    public $brand;
    public $model;

    public function start() {
        echo "La voiture démarre.";
    }
}

// Création d'un objet
$myCar = new Car();

$myCar->brand = "Toyota";

$myCar->model = "Corolla";

$myCar->start(); // Affichera : "La voiture démarre."
----

== Constructeur : 

Le constructeur est une méthode spéciale d'une classe qui est appelée automatiquement lors de la création d'un objet. 

=== ...

En PHP, il est défini avec le mot-clé __construct(). 

=== ...

Il permet d'initialiser les propriétés de l'objet au moment où celui-ci est créé.


=== Exemple d'utilisation d'un constructeur :

[source, php]
----
class Car {
    public $brand;
    public $model;

    // Constructeur
    public function __construct($brand, $model) {
        $this->brand = $brand;
        $this->model = $model;
    }

    public function start() {
        echo "La voiture $this->brand $this->model démarre.";
    }
}

// Création d'un objet avec le constructeur
$myCar = new Car("Toyota", "Corolla");

$myCard->start(); // Affichera : "La voiture Toyota Corolla démarre."

----

== Bonnes pratiques pour l'initialisation des objets :

=== Utilisation des constructeurs pour des valeurs obligatoires :

Si certaines propriétés doivent toujours être initialisées avec des valeurs spécifiques, il est recommandé de les définir dans le constructeur. 

=== ...

Cela garantit que chaque objet aura les valeurs nécessaires dès sa création.

=== Exemple :

[source, php]
----
class User {
    public $name;
    public $email;

    // Constructeur pour obliger la fourniture du name et de l'email

    public function __construct($name, $email) {
        $this->name = $name;
        $this->email = $email;
    }
}

// Oblige l'utilisateur à fournir name et email lors de la création
$user = new User("Jean", "jean@example.com");
----

=== Réduire la complexité du constructeur :

Évitez d'avoir trop de paramètres dans un constructeur. 

=== ...

Un constructeur avec trop de paramètres devient difficile à lire et à maintenir. 

=== ...

Utilisez des valeurs par défaut ou des setters pour simplifier l'initialisation.

=== Exemple avec valeurs par défaut :

[source, php]
----
class Car {
    public $brand;
    public $model;
    public $color;

    // Constructeur avec valeur par défaut
    public function __construct($brand, $model, $color = "blanche") {
        $this->brand = $brand;
        $this->model = $model;
        $this->color = $color;
    }
}

$Car1 = new Car("Toyota", "Corolla"); // Couleur par défaut : blanche
$Car2 = new Car("Honda", "Civic", "rouge"); // Couleur spécifiée : rouge
----

=== Encapsulation et utilisation des setters pour les valeurs optionnelles :

Lorsque certaines propriétés ne sont pas obligatoires au moment de la création de l'objet, il est préférable d'utiliser des méthodes setter pour leur assignation. 

=== ...

Cela permet de garder le constructeur propre et de gérer ces valeurs de manière indépendante.

=== Exemple d’utilisation d’un setter :

[source, php]
----
class Car {
    private $brand;
    private $model;
    private $color;

    public function __construct($brand, $model) {
        $this->brand = $brand;
        $this->model = $model;
    }

    public function setColor($color) {
        $this->color = $color;
    }

    public function start() {
        echo "La voiture $this->brand $this->model de couleur $this->color démarre.";
    }
}


// Création d'un objet avec constructeur
$myCar = new Car("Toyota", "Corolla");
$myCar->setColor("Rouge"); // Couleur optionnelle
$myCar->start(); // Affichera : "La voiture Toyota Corolla de couleur Rouge démarre."
----

== Utilisation des null coalescing operators (??) :

Lors de l'initialisation des objets, vous pouvez utiliser l'opérateur ?? pour définir des valeurs par défaut en cas d'absence de certaines données.

=== Exemple :

[source, php]
----
class Product {
    public $name;
    public $price;

    public function __construct($name, $price = null) {
        // Si le prix n'est pas fourni, il prend la valeur par défaut de 10
        $this->price = $price ?? 10;
        $this->name = $name;
    }
}

$product1 = new Product("Ordinateur", 500);
$product2 = new Product("Souris"); // Le prix sera par défaut de 10
----

== Initialisation paresseuse (Lazy Initialization) :

L'initialisation paresseuse consiste à ne pas initialiser certaines ressources lourdes (comme la connexion à une base de données) tant qu'elles ne sont pas réellement nécessaires. 

=== ...

Cela permet d'améliorer les performances et de réduire la consommation de mémoire.

=== Exemple :

[source, php]
----
class BaseDeDonnées {
    private $connexion;

    public function getConnexion() {
        if ($this->connexion === null) {
            // Initialisation paresseuse de la connexion
            $this->connexion = new PDO('mysql:host=localhost;dbname=maDB', 'user', 'password');
        }
        return $this->connexion;
    }
}
----



//---------------------------------------------------------------


== Encapsulation : 

Importance des modificateurs d'accès private, protected, et public pour sécuriser et structurer le code.

//----------------
=== ...

Les modificateurs d'accès en programmation orientée objet (POO) permettent de contrôler la visibilité des propriétés et méthodes d'une classe. 


=== ...

En PHP, ces modificateurs sont public, protected et private. 


=== ...

Leur utilisation est essentielle pour structurer le code de manière sécurisée et maintenable, en définissant clairement ce qui peut ou ne peut pas être accédé depuis l'extérieur de la classe ou par les classes dérivées.

== Modificateurs d'accès en PHP :

=== Public (public) :

Les propriétés et méthodes déclarées avec le mot-clé public sont accessibles de n'importe où : 

=== ...

[%step]
* à la fois depuis l'intérieur de la classe
* depuis les classes dérivées (en cas d'héritage)
* depuis l'extérieur de la classe (les instances d'objets peuvent y accéder directement).

=== ...

=== Avantages : 

Simple à utiliser pour des propriétés ou méthodes qui doivent être accessibles sans restriction.

=== Inconvénients : 

Si trop de données ou de fonctionnalités sont publiques, cela peut conduire à une mauvaise encapsulation, ce qui rend le code plus difficile à maintenir.


=== Exemple :

[source, php]
----
class Car {
    public $brand;

    public function start() {
        echo "La voiture démarre.";
    }
}

// Accès public
$myCar = new Car();
$myCar->brand = "Toyota"; // Possible car $brand est public
$myCar->start(); // Possible car start() est public
----


=== Protected (protected) :

Les propriétés et méthodes déclarées avec le mot-clé protected ne sont accessibles que:
[%step]
* à l'intérieur de la classe 
* dans les classes dérivées (c'est-à-dire les classes enfants qui héritent de cette classe). 

=== ...

Elles ne sont pas accessibles directement depuis l'extérieur de la classe.


=== Avantages : 

Cela protège certaines parties du code contre des modifications directes depuis l'extérieur tout en permettant leur utilisation dans les classes dérivées, garantissant une meilleure encapsulation.


=== Inconvénients : 

Moins flexible qu'un accès public, mais il est utile pour protéger des éléments internes tout en permettant une certaine extensibilité.

=== Exemple :

[source, php]
----
class Car {
    protected $brand;

    public function setBrand($brand) {
        $this->brand = $brand;
    }
}

class ElectricCar extends Car {
    public function displayBrand() {
        echo "La brand de la voiture électrique est : " . $this->brand;
    }
}

$electricCar = new ElectricCar();
$electricCar->setBrand("Tesla"); // Possible via la méthode publique setBrand()
$electricCar->displayBrand(); // Possible car displayBrand() est dans une classe dérivée
----







=== Private (private) :

Les propriétés et méthodes déclarées avec le mot-clé private ne sont accessibles que 
depuis l'intérieur de la classe dans laquelle elles sont définies. 

=== ...

Elles ne sont pas accessibles depuis les classes dérivées, ni depuis l'extérieur de la classe.

=== Avantages : 

Permet de protéger totalement les données ou les comportements internes d'une classe, empêchant toute modification directe depuis l'extérieur ou même depuis les sous-classes. 

=== ...

Cela garantit une encapsulation complète.


=== Inconvénients : 

Moins flexible car les sous-classes ne peuvent pas y accéder directement, mais cela renforce la sécurité et l'intégrité des données.

=== Exemple :

[source, php]
----
class Car {
    private $brand;

    public function setBrand($brand) {
        $this->brand = $brand;
    }

    public function displayBrand() {
        echo "La brand de la Car est : " . $this->brand;
    }
}

$myCar = new Car();
$myCar->setBrand("Toyota"); // Possible car setBrand() est public
$myCar->displayBrand(); // Possible car displayBrand() est public
//$myCar->brand = "Honda"; // Erreur : $brand est private
----

== Pourquoi utiliser les modificateurs d'accès ?

=== Encapsulation : 

L'encapsulation est un des principes clés de la programmation orientée objet. 

=== ...

Elle consiste à cacher les détails internes d'une classe (comme les données ou les méthodes) et à ne fournir qu'une interface contrôlée et sécurisée pour interagir avec ces détails. 

=== ....

Les modificateurs d'accès (private, protected, public) sont essentiels pour mettre en place cette encapsulation.

=== Exemple d'encapsulation avec des setters et getters :

[source, php]
----
class CompteBancaire {
    private $solde = 0;

    public function deposer($montant) {
        $this->solde += $montant;
    }

    public function retirer($montant) {
        if ($montant > $this->solde) {
            echo "Solde insuffisant.";
        } else {
            $this->solde -= $montant;
        }
    }

    public function getSolde() {
        return $this->solde;
    }
}

$compte = new CompteBancaire();
$compte->deposer(500);
echo $compte->getSolde(); // Affichera 500
----

=== ...

Ici, l'accès au solde du compte est limité à travers des méthodes spécifiques (setters et getters). 


=== ...

L'utilisateur ne peut pas directement modifier ou accéder à la propriété $solde, ce qui empêche des modifications inattendues ou des erreurs.

=== Sécurité et intégrité des données : 

En utilisant les modificateurs private et protected, vous pouvez protéger les propriétés et méthodes sensibles pour éviter qu'elles soient modifiées directement par des utilisateurs externes ou par des sous-classes qui ne devraient pas avoir ce niveau d'accès.

=== ...

Par exemple, dans le cas d'une application bancaire, vous ne voulez pas que le solde du compte soit modifié directement depuis l'extérieur. 

=== ...

Vous utiliserez donc private pour cette propriété et fournirez des méthodes publiques pour la manipulation des valeurs de manière contrôlée.


=== Faciliter la maintenance et l'évolution du code : 

En restreignant l'accès à certaines parties du code, vous pouvez plus facilement modifier ou réorganiser l'implémentation interne sans affecter les autres parties du programme ou les classes qui héritent de celle-ci. 

=== ...

Par exemple, si vous changez l'implémentation d'une méthode privée, cela n'impactera pas le code externe ou les sous-classes.

=== Meilleure organisation du code et séparation des responsabilités : 


Les modificateurs d'accès vous aident à mieux organiser votre code. 


=== ...

Vous pouvez clairement séparer ce qui est exposé à l'extérieur d'une classe (les méthodes publiques) de ce qui est caché et géré en interne (les propriétés privées et protégées). 


=== ...

Cela favorise la création d'une interface publique bien définie, facilitant ainsi l'utilisation de vos objets par d'autres développeurs ou modules.




//-----------------------------------------------------------------------------


== Constructeurs et destructeurs : 

Utilisation des méthodes magiques __construct() et __destruct().


=== ...

Les méthodes magiques en PHP sont des méthodes spéciales qui commencent par deux underscores (__). 


=== ...

Elles sont appelées automatiquement dans certains contextes particuliers. 


Parmi les plus courantes, on trouve __construct() et __destruct(). 



Ces deux méthodes jouent un rôle essentiel dans la gestion de la vie des objets en PHP.

== Méthode __construct() :

=== Qu'est-ce que __construct() ?

La méthode __construct() est le constructeur d'une classe en PHP. 

=== ...

Elle est automatiquement appelée lorsque vous instanciez un objet de cette classe avec le mot-clé new. 


=== ...

Son rôle principal est d'initialiser l'objet, c'est-à-dire de définir les valeurs initiales des propriétés ou de préparer toute autre ressource nécessaire pour l'objet.

== Comment utiliser __construct() ?


=== Initialisation des propriétés : 

La méthode __construct() est utilisée pour définir les propriétés d'une classe avec des valeurs fournies lors de la création de l'objet.

=== Exemple :

[source, php]
----
class Car {
    public $brand;
    public $model;

    // Constructeur qui initialise les propriétés de la voiture
    public function __construct($brand, $model) {
        $this->brand = $brand;
        $this->model = $model;
    }

    public function displayDetails() {
        echo "La voiture est une $this->brand $this->model.";
    }
}

// Création d'un objet avec initialisation des propriétés via le constructeur
$myCar = new Car("Toyota", "Corolla");
$myCar->displayDetails(); // Affichera : "La voiture est une Toyota Corolla."
----


== Gestion de la logique d'initialisation : 

Le constructeur peut aussi contenir une logique plus complexe, comme:
[%step]
* la connexion à une base de données, 
* le chargement de fichiers, 
* la validation des données fournies lors de l'instanciation.

=== Exemple :

[source, php]
----
class DataBase {
    private $connexion;

    // Le constructeur tente de se connecter à la base de données
    public function __construct($host, $dbname, $user, $pass) {
        try {
            $this->connexion = new PDO("mysql:host=$host;dbname=$dbname", $user, $pass);
            echo "Connexion réussie à la base de données.";
        } catch (PDOException $e) {
            echo "Erreur : " . $e->getMessage();
        }
    }
}

// Création d'une instance de la classe qui initialise la connexion à la BDD
$db = new DataBase('localhost', 'maBDD', 'utilisateur', 'motdepasse');
----


=== Valeurs par défaut dans le constructeur : 

Si certaines propriétés ne sont pas toujours fournies lors de l'instanciation, vous pouvez spécifier des valeurs par défaut dans le constructeur.

=== Exemple :

[source, php]
----
class Produit {
    public $nom;
    public $prix;

    // Le constructeur définit un prix par défaut si aucun prix n'est fourni
    public function __construct($nom, $prix = 10) {
        $this->nom = $nom;
        $this->prix = $prix;
    }

    public function afficherPrix() {
        echo "Le prix du produit $this->nom est $this->prix €.";
    }
}

$produit1 = new Produit("Ordinateur", 500);
$produit2 = new Produit("Souris"); // Prix par défaut : 10 €

$produit1->afficherPrix(); // Affichera : "Le prix du produit Ordinateur est 500 €."
$produit2->afficherPrix(); // Affichera : "Le prix du produit Souris est 10 €."
----

== Méthode __destruct() :

=== Qu'est-ce que __destruct() ?

La méthode __destruct() est le destructeur d'une classe en PHP. 

=== ...

Elle est automatiquement appelée lorsque l'objet est détruit, c'est-à-dire lorsqu'il n'est plus référencé (par exemple, lorsque le script se termine ou que l'objet est explicitement supprimé). 

=== ...

Son rôle principal est de libérer les ressources utilisées par l'objet, comme:
[%step]
* fermer une connexion à une base de données, 
* vider un fichier temporaire, etc.

== Comment utiliser __destruct() ?

=== Libérer les ressources (connexion à une base de données, fichier, etc.) : 

Le destructeur est souvent utilisé pour fermer proprement des connexions ou des fichiers qui ont été ouverts lors de l'utilisation de l'objet.


=== Exemple :

[source, php]
----
class DataBase {
    private $connexion;

    // Connexion à la base de données via le constructeur
    public function __construct($host, $dbname, $user, $pass) {
        $this->connexion = new PDO("mysql:host=$host;dbname=$dbname", $user, $pass);
        echo "Connexion à la base de données établie.<br>";
    }

    // Fermeture de la connexion à la base de données lors de la destruction de l'objet
    public function __destruct() {
        $this->connexion = null;
        echo "Connexion à la base de données fermée.<br>";
    }
}
// Création et destruction automatique de l'objet
$db = new DataBase('localhost', 'maBDD', 'utilisateur', 'motdepasse');
----

=== ...

Dans cet exemple, le destructeur libère la connexion à la base de données lorsque l'objet $db est détruit (ce qui se produit automatiquement à la fin du script ou lorsqu'il n'est plus utilisé).


=== Nettoyage des fichiers ou des ressources temporaires : 

Si l'objet a utilisé des ressources temporaires comme des fichiers, le destructeur peut les nettoyer avant que l'objet ne soit détruit.


=== Exemple :

[source, php]
----
class TemporaryFile {
    private $path;

    // Création d'un fichier temporaire
    public function __construct($path) {
        $this->path = $path;
        file_put_contents($this->path, "Contenu temporaire");
        echo "Fichier temporaire créé : $this->path<br>";
    }

    // Suppression du fichier temporaire lors de la destruction de l'objet
    public function __destruct() {
        if (file_exists($this->path)) {
            unlink($this->path); // Suppression du fichier
            echo "Fichier temporaire supprimé : $this->path<br>";
        }
    }
}

// Création et destruction automatique du fichier temporaire
$fichier = new TemporaryFile("temporary.txt");
----

=== ...

Ici, le fichier temporaire est supprimé lorsque l'objet $fichier est détruit, assurant ainsi que les ressources sont nettoyées correctement.

=== Débogage : 


Vous pouvez aussi utiliser le destructeur pour suivre les moments où des objets sont détruits.

=== ...

C'utile pour détecter les fuites de mémoire ou comprendre la durée de vie des objets.




== Différences entre __construct() et __destruct() :


__construct() est appelé lorsque l'objet est instancié. 


=== ...

Il est utilisé pour initialiser l'objet avec des données ou pour préparer des ressources nécessaires à son fonctionnement.

=== ...

__destruct() est appelé lorsque l'objet est détruit. 

=== ...

Il est utilisé pour libérer les ressources allouées par l'objet, telles que:
[%step]
* les connexions aux bases de données, 
* les fichiers temporaires, 
* etc.

//------------------------------------

=== Concepts avancés de POO 

== Héritage : 

Étendre une classe pour en hériter les fonctionnalités.

=== ...

En programmation orientée objet (POO), l'héritage est un mécanisme qui permet à une classe de **dériver** d'une autre classe, héritant ainsi de ses propriétés et méthodes. 

=== ...

Cela permet de réutiliser du code et de créer des structures hiérarchiques où une classe "enfant" (ou sous-classe) peut étendre ou modifier les fonctionnalités d'une classe "parent" (ou super-classe).




== Concept de base de l'héritage :

=== Lorsqu'une classe hérite d'une autre :

Elle obtient toutes les propriétés et méthodes de la classe parente, à l'exception de celles qui sont privées (private).

=== ...

Elle peut ajouter de nouvelles propriétés ou méthodes spécifiques à elle-même.

=== ...

Elle peut surcharger (ou redéfinir) des méthodes de la classe parente pour les adapter à ses besoins spécifiques.

=== ...

== Syntaxe de l'héritage en PHP :

Pour hériter d'une classe en PHP, on utilise le mot-clé extends.

[source, php]
----
class ClasseParente {
    // Propriétés de la classe parente
    public $propriete;

    // Méthode de la classe parente
    public function afficher() {
        echo "Méthode de la classe parente.";
    }
}

class ClasseEnfant extends ClasseParente {
    // Propriétés et méthodes supplémentaires ou modifiées
}
----

=== Exemple d'héritage simple :


Supposons que nous ayons une classe Voiture qui représente les caractéristiques de base d'une voiture, et nous voulons créer une classe VoitureElectrique qui hérite de cette classe tout en ajoutant des fonctionnalités supplémentaires spécifiques aux voitures électriques.

[source, php]
----
// Classe parente
class Car {

    public $brand;
    public $model;

    public function __construct($brand, $model) {
        $this->brand = $brand;
        $this->model = $model;
    }

    public function start() {
        echo "La voiture $this->brand $this->model démarre.<br>";
    }

    public function stop() {
        echo "La voiture $this->brand $this->model s'arrête.<br>";
    }
}

// Classe enfant qui hérite de Car
class ElectricCar extends Car {
    public $autonomie;

    // Constructeur qui initialise également l'autonomie spécifique aux voitures électriques

    public function __construct($brand, $model, $autonomy) {

        // Appel du constructeur de la classe parente
        parent::__construct($brand, $model);
        $this->autonomy = $autonomy;

    }

    // Nouvelle méthode spécifique aux voitures électriques
    public function reload() {
        echo "La voiture $this->brand $this->model est en train de se recharger.<br>";
    }

    // Surcharger la méthode "start" pour ajouter un comportement spécifique
    public function start() {
        echo "La voiture électrique $this->brand $this->model démarre silencieusement.<br>";
    }
}

// Utilisation de l'héritage
$car1 = new Car("Toyota", "Corolla");
$car1->start(); // Affichera : La voiture Toyota Corolla démarre.

$voitureElec = new ElectricCar("Tesla", "Model S", 600);
$voitureElec->start();  // Affichera : La voiture électrique Tesla Model S démarre silencieusement.
$voitureElec->reload(); // Affichera : La voiture Tesla Model S est en train de se recharger.
----

== Explication de l'exemple :

=== Classe parente Voiture :

Cette classe contient les propriétés brand et model, ainsi que les méthodes start() et stop().

=== ...

Le constructeur initialise les propriétés brand et model.

=== Classe enfant ElectricCar :

Cette classe hérite de toutes les propriétés et méthodes de la classe Voiture.

=== ...

Elle ajoute une nouvelle propriété autonomy, qui est spécifique aux voitures électriques.

=== ...

Le constructeur de la classe enfant appelle le constructeur de la classe parente avec parent::__construct(), puis ajoute des comportements spécifiques (l'initialisation de l'autonomie).

=== ...

La méthode start() est surchargée pour modifier le comportement spécifique des voitures électriques.

=== ...

Une nouvelle méthode reload() est ajoutée, car elle est spécifique aux voitures électriques.

=== Appel des méthodes et propriétés de la classe parente avec parent:: :


Lorsqu'une classe enfant hérite d'une classe parente, elle peut accéder aux méthodes et propriétés de la classe parente via le mot-clé parent::. 

=== ...

Cela est particulièrement utile lorsqu'on souhaite appeler une méthode ou un constructeur de la classe parente à partir de la classe enfant.

=== ...

Dans l'exemple précédent, nous avons utilisé parent::__construct() pour appeler le constructeur de la classe Voiture depuis la classe ElectricCar. 

=== ...

Cela permet de s'assurer que les propriétés de la classe parente sont bien initialisées avant de continuer à initialiser les propriétés spécifiques à la classe enfant.

== Surcharger des méthodes :

La surcharge (ou redéfinition) est le processus par lequel une classe enfant modifie une méthode héritée de la classe parente pour lui donner un comportement différent. 

=== ...

Dans notre exemple, la classe ElectricCar a surchargé la méthode start() pour ajouter un comportement spécifique aux voitures électriques.

=== ...

Lorsque la méthode start() est appelée sur une instance de ElectricCar, c'est la version surchargée qui est exécutée, et non celle de la classe parente.

== Héritage et modificateurs d'accès (public, protected, private) :

Les propriétés et méthodes public de la classe parente sont accessibles à la classe enfant et à l'extérieur.

=== ...

Les propriétés et méthodes protected sont accessibles à la classe enfant mais pas à l'extérieur de celle-ci.

=== ...

Les propriétés et méthodes private ne sont accessibles qu'à l'intérieur de la classe où elles sont définies. 

=== ...

Elles ne sont pas visibles par la classe enfant.

=== Exemple avec protected :

[source, php]
----
class Car {
    protected $brand;

    public function __construct($brand) {
        $this->brand= $brand;
    }

    protected function start() {
        echo "La voiture démarre.<br>";
    }
}

class SportCar extends Car {
    public function startSport() {
        // On peut accéder à la méthode et la propriété protected
        echo "La voiture sport $this->brand démarre en mode sport.<br>";
        $this->start();
    }
}

$voitureSport = new SportCar("Ferrari");
$voitureSport->startSport(); // Affichera : "La voiture sport Ferrari démarre en mode sport."
----

=== Dans cet exemple :

La méthode start() et la propriété brand sont protected, donc elles sont accessibles depuis la classe enfant SportCar, mais elles ne sont pas accessibles directement depuis l'extérieur (une instance d'objet ne pourrait pas les appeler ou les modifier directement).




//--------------------------------------------------------------------------

== Polymorphisme : 

Utilisation des interfaces et des classes abstraites pour implémenter plusieurs comportements en fonction du contexte.

//-------------------------------------------------------------------------------

Les interfaces et les classes abstraites sont des concepts importants en programmation orientée objet (POO). 

=== ...

Ils permettent de définir des structures et des contrats pour les classes qui les implémentent ou les étendent.

=== ...

Leur utilisation est essentielle lorsque vous devez créer des systèmes qui permettent à plusieurs classes de partager certains comportements tout en ayant la flexibilité d'implémenter leurs propres fonctionnalités spécifiques.

== Les interfaces :

=== Une interface en PHP définit un contrat : 

Elle énumère des méthodes que les classes doivent implémenter, mais elle ne contient pas de code implémenté (pas de corps de méthode). 

=== ...

Une classe qui implémente une interface s'engage à implémenter toutes les méthodes définies dans cette interface.

=== Utilisation des interfaces :

Les interfaces sont utiles lorsque vous avez différentes classes qui doivent implémenter des méthodes similaires mais peuvent le faire de manière différente.

=== ...

Une interface ne peut pas contenir de code concret (pas de propriétés ni de méthodes avec corps), seulement des déclarations de méthodes publiques.


=== ...

Une classe peut implémenter plusieurs interfaces, ce qui permet à une classe d'avoir plusieurs comportements.

=== Exemple d'interface :


[source, php]
----
interface Reparable {
    public function reparer();
}

interface Rechargeable {
    public function recharger();
}

// Classe Voiture qui implémente l'interface Reparable
class Voiture implements Reparable {

    public function reparer() {
        echo "La voiture est réparée.<br>";
    }
}

// Classe VoitureElectrique qui implémente deux interfaces : Reparable et Rechargeable
class VoitureElectrique implements Reparable, Rechargeable {
    public function reparer() {
        echo "La voiture électrique est réparée.<br>";
    }

    public function recharger() {
        echo "La voiture électrique est en train de se recharger.<br>";
    }
}

// Utilisation des classes qui implémentent des interfaces
$voiture = new Voiture();
$voiture->reparer(); // Affichera : La voiture est réparée.

$voitureElec = new VoitureElectrique();
$voitureElec->reparer();  // Affichera : La voiture électrique est réparée.
$voitureElec->recharger(); // Affichera : La voiture électrique est en train de se recharger.
----


=== Explication :

Reparable et Rechargeable sont des interfaces qui définissent les méthodes reparer() et recharger() respectivement. 

=== ...

Ces interfaces forcent toute classe qui les implémente à fournir une implémentation de ces méthodes.

=== ....

La classe Voiture implémente uniquement l'interface Reparable, elle doit donc uniquement fournir l'implémentation de reparer().


=== ....

La classe VoitureElectrique implémente deux interfaces (Reparable et Rechargeable), elle doit donc implémenter les deux méthodes reparer() et recharger().

=== ....

L'avantage des interfaces est que cela permet à une classe d'avoir plusieurs comportements en fonction des interfaces qu'elle implémente.


== Les classes abstraites :

Une classe abstraite est similaire à une classe régulière, mais elle ne peut pas être instanciée directement. 

=== ...

Elle sert de modèle pour d'autres classes. 

=== ...

Contrairement à une interface, une classe abstraite peut contenir des méthodes avec une implémentation partielle ou complète, mais elle peut également contenir des méthodes abstraites (sans corps) que les classes dérivées doivent implémenter.

== Utilisation des classes abstraites :


Les classes abstraites sont utilisées lorsqu'on veut fournir une implémentation par défaut de certaines méthodes, tout en forçant les classes dérivées à implémenter d'autres méthodes.

=== ...

Contrairement aux interfaces, une classe abstraite peut contenir des propriétés et des méthodes avec une implémentation concrète.

=== ...

Une classe ne peut hériter que d'une seule classe abstraite (limitation de l'héritage simple en PHP).


=== Exemple de classe abstraite :

[source, php]
----
abstract class Vehicule {
    protected $marque;
    protected $modele;

    // Constructeur commun à toutes les classes qui dérivent de Vehicule
    public function __construct($marque, $modele) {
        $this->marque = $marque;
        $this->modele = $modele;
    }

    // Méthode abstraite, les classes dérivées doivent l'implémenter
    abstract public function demarrer();

    // Méthode concrète que les classes dérivées peuvent utiliser telle quelle ou redéfinir
    public function arreter() {
        echo "Le véhicule $this->marque $this->modele s'arrête.<br>";
    }
}

// Classe Voiture qui hérite de la classe abstraite Vehicule
class Voiture extends Vehicule {
    // Implémentation de la méthode abstraite
    public function demarrer() {
        echo "La voiture $this->marque $this->modele démarre.<br>";
    }
}

// Classe Moto qui hérite de la classe abstraite Vehicule
class Moto extends Vehicule {
    // Implémentation de la méthode abstraite
    public function demarrer() {
        echo "La moto $this->marque $this->modele démarre.<br>";
    }
}

// Utilisation des classes dérivées
$voiture = new Voiture("Toyota", "Corolla");
$voiture->demarrer(); // Affichera : La voiture Toyota Corolla démarre.
$voiture->arreter();  // Affichera : Le véhicule Toyota Corolla s'arrête.

$moto = new Moto("Yamaha", "MT-09");
$moto->demarrer();    // Affichera : La moto Yamaha MT-09 démarre.
$moto->arreter();     // Affichera : Le véhicule Yamaha MT-09 s'arrête.
----

=== Explication :

La classe Vehicule est une classe abstraite. 

=== ...


Elle définit une méthode abstraite demarrer(), que toutes les classes qui héritent de Vehicule doivent implémenter.

=== ...

Voiture et Moto sont des classes concrètes qui héritent de Vehicule. 


=== ...

Elles doivent fournir leur propre implémentation de la méthode demarrer().


=== ...

La classe abstraite Vehicule a également une méthode concrète arreter(), qui est commune à tous les véhicules et peut être utilisée telle quelle ou redéfinie dans les classes enfants.


== Combinaison d'interfaces et de classes abstraites :

Il est possible d'utiliser à la fois des interfaces et des classes abstraites dans une même architecture. 

=== ...

Par exemple, une classe abstraite peut implémenter une ou plusieurs interfaces.

=== Exemple de combinaison :
[source, php]
----
interface Volant {
    public function voler();
}

abstract class Oiseau implements Volant {
    public function manger() {
        echo "L'oiseau mange.<br>";
    }

    // Les classes enfants doivent implémenter cette méthode
    abstract public function chanter();
}

// Classe enfant qui hérite de la classe abstraite et implémente l'interface
class Aigle extends Oiseau {
    public function voler() {
        echo "L'aigle vole haut dans le ciel.<br>";
    }

    public function chanter() {
        echo "L'aigle émet des cris perçants.<br>";
    }
}

$aigle = new Aigle();
$aigle->voler();  // Affichera : L'aigle vole haut dans le ciel.
$aigle->manger(); // Affichera : L'oiseau mange.
$aigle->chanter(); // Affichera : L'aigle émet des cris perçants.
----

=== Explication :

Volant est une interface qui impose la méthode voler().

=== ...

Oiseau est une classe abstraite qui implémente l'interface Volant et qui contient à la fois une méthode concrète manger() et une méthode abstraite chanter().

=== ...

Aigle est une classe concrète qui hérite de Oiseau et implémente toutes les méthodes requises par l'interface et la classe abstraite.



//-------------------------------------------------------------------------------
== Exemple pratique : 

Créer une interface Rechargeable avec une méthode recharger(), puis la mettre en œuvre dans VoitureElectrique.




== Late Static Binding : 

Compréhension du mot-clé static et du comportement self vs static.

=== ...
//-----------------------------STATIC--------------------------------

En PHP, le mot-clé static est utilisé pour définir des propriétés et des méthodes statiques. 


=== ...

Ces propriétés et méthodes appartiennent à la classe elle-même plutôt qu'à une instance spécifique de la classe. 

=== ...

Cela signifie qu'elles peuvent être utilisées sans qu'un objet ne soit créé.


=== ...

De plus, self et static sont deux mots-clés qui sont souvent utilisés en combinaison avec static pour référencer des propriétés ou des méthodes statiques, mais ils fonctionnent différemment dans le contexte de l'héritage.


== Le mot-clé static :

=== Méthodes statiques :

Les méthodes statiques peuvent être appelées directement sur la classe sans créer d'instance. 

=== ...

Elles sont définies avec le mot-clé static.

=== Exemple de méthode statique :

[source, php]
----
class Math {
    public static function addition($a, $b) {
        return $a + $b;
    }
}

// Appel de la méthode statique sans créer d'objet
echo Math::addition(5, 10); // Affichera 15
----


=== Propriétés statiques :

Les propriétés statiques fonctionnent de manière similaire aux méthodes statiques. 


Elles sont partagées par toutes les instances d'une classe, ce qui signifie qu'elles ne sont pas spécifiques à une instance d'objet mais communes à toutes les instances.

=== Exemple de propriété statique :

[source, php]
----
class Compteur {
    public static $nombre = 0;

    public static function incrementer() {
        self::$nombre++;
    }
}

// Utilisation de la propriété statique sans créer d'objet
Compteur::incrementer();
echo Compteur::$nombre; // Affichera 1

Compteur::incrementer();
echo Compteur::$nombre; // Affichera 2
----


== Différence entre self et static dans le contexte de l'héritage :

=== Le mot-clé self :

self fait référence à la classe où il est défini. 

=== ...

Lorsque vous utilisez self, PHP utilisera la méthode ou la propriété statique de la classe actuelle, même si la méthode est appelée depuis une classe dérivée (enfant).


=== ...

Cela signifie que self ne prend pas en compte l'héritage dynamique et fait référence à la classe statiquement définie.

=== Exemple avec self :

[source, php]
----
class ParentClass {
    public static function quiSuisJe() {
        echo "Je suis la classe ParentClass.<br>";
    }

    public static function appeler() {
        self::quiSuisJe();
    }
}

class EnfantClass extends ParentClass {
    public static function quiSuisJe() {
        echo "Je suis la classe EnfantClass.<br>";
    }
}

// Appel via la classe parent
ParentClass::appeler(); // Affichera : Je suis la classe ParentClass.

// Appel via la classe enfant
EnfantClass::appeler(); // Affichera : Je suis la classe ParentClass.
----


=== Explication :

Dans cet exemple, lorsque self::quiSuisJe() est appelé dans la méthode appeler(), il fait référence à la méthode quiSuisJe() définie dans ParentClass, même si appeler() est appelé à partir de EnfantClass. 


Cela montre que self fait référence à la classe où il est défini statiquement et non à la classe d'où la méthode est appelée.


=== Le mot-clé static (Late Static Binding) :

static, lorsqu'il est utilisé, introduit un concept appelé liaison statique tardive (Late Static Binding). 

=== ...

Cela permet de faire référence à la classe qui a effectivement appelé la méthode, c'est-à-dire la classe actuelle lors de l'exécution. Ainsi, contrairement à self, static est résolu dynamiquement.

=== ...

Cela permet à une méthode dans une classe parent d'appeler une méthode redéfinie dans une classe enfant.

=== Exemple avec static :

[source, php]
----
class ParentClass {
    public static function quiSuisJe() {
        echo "Je suis la classe ParentClass.<br>";
    }

    public static function appeler() {
        static::quiSuisJe();
    }
}

class EnfantClass extends ParentClass {
    public static function quiSuisJe() {
        echo "Je suis la classe EnfantClass.<br>";
    }
}

// Appel via la classe parent
ParentClass::appeler(); // Affichera : Je suis la classe ParentClass.

// Appel via la classe enfant
EnfantClass::appeler(); // Affichera : Je suis la classe EnfantClass.
----

=== Explication :


Dans cet exemple, lorsque static::quiSuisJe() est utilisé dans la méthode appeler(), PHP utilise la méthode quiSuisJe() de la classe qui appelle réellement la méthode (ce qui est EnfantClass dans le deuxième appel). 

=== ...

Cela montre que static est résolu dynamiquement en fonction de la classe qui effectue l'appel.


== Quand utiliser self et static ?

Utiliser self lorsque vous voulez être sûr que la méthode ou la propriété appelée est celle de la classe actuelle, sans tenir compte des sous-classes.


=== Cas d'utilisation :

[%step]
* lorsque vous savez que le comportement ne doit pas être modifié dans les sous-classes
* lorsque la méthode ou la propriété est spécifique à la classe définie et ne doit pas être surchargée.

=== ...

Utiliser static (Late Static Binding) lorsque vous voulez que le comportement tienne compte de la classe qui fait l'appel, même si l'appel est effectué depuis une sous-classe.

=== Cas d'utilisation : 


Lorsque vous voulez permettre aux sous-classes de redéfinir une méthode ou une propriété et que la classe parente doit appeler la méthode/propriété correcte en fonction de la classe qui fait l'appel.


== Exemple pratique de self et static :


[source, php]
----
class Animal {
    public static function identifier() {
        self::getNom();
    }

    public static function identifierDynamique() {
        static::getNom();
    }

    public static function getNom() {
        echo "Je suis un animal.<br>";
    }
}

class Chien extends Animal {
    public static function getNom() {
        echo "Je suis un chien.<br>";
    }
}

// Appel avec self
Animal::identifier(); // Affichera : Je suis un animal.
Chien::identifier();  // Affichera : Je suis un animal.

// Appel avec static
Animal::identifierDynamique(); // Affichera : Je suis un animal.
Chien::identifierDynamique();  // Affichera : Je suis un chien.
----

=== Explication :

self::getNom() utilise la méthode définie dans la classe Animal, même lorsque identifier() est appelée depuis Chien. 


Cela montre que self fait référence à la classe où la méthode est définie, et non à la classe qui fait l'appel.

static::getNom(), en revanche, tient compte de la classe qui fait l'appel. Lorsque identifierDynamique() est appelée depuis Chien, PHP appelle la méthode getNom() de Chien.




//-----------------------------END OF STATIC--------------------------------


== Traits : 

Réutilisation de morceaux de code à travers plusieurs classes sans utiliser l’héritage.

//-------------------------------------------------------------------

=== ...

Les traits en PHP sont un mécanisme permettant de réutiliser du code à travers plusieurs classes sans avoir à utiliser l'héritage. 


=== ...

Ils sont particulièrement utiles lorsque vous avez des morceaux de code (méthodes) que plusieurs classes doivent partager, mais que vous ne pouvez pas ou ne voulez pas utiliser l'héritage classique. 

=== ...

En PHP, une classe peut utiliser plusieurs traits, ce qui permet une flexibilité accrue par rapport à l'héritage simple, où une classe ne peut hériter que d'une seule autre classe.

== Pourquoi utiliser des traits ?

=== Réutilisation de code : 

Un trait permet de définir un ensemble de méthodes qui peuvent être utilisées dans plusieurs classes.

=== Évite les limites de l'héritage simple : 

En PHP, une classe ne peut hériter que d'une seule classe. 

=== ...

Les traits permettent de contourner cette limitation en "injectant" des méthodes dans plusieurs classes.

=== Séparation des préoccupations : 

Les traits permettent de découper des fonctionnalités réutilisables en unités logiques distinctes, rendant le code plus modulaire et facile à maintenir.

=== Définition d’un trait :

Un trait est défini avec le mot-clé trait. 

=== ...

Ensuite, pour qu'une classe utilise ce trait, on utilise le mot-clé **use** à l'intérieur de la classe.

=== Exemple simple d'utilisation d'un trait :


[source, php]
----
trait Logger {
    public function log($message) {
        echo "[LOG] " . $message . "<br>";
    }
}

trait FileLogger {
    public function logToFile($filename, $message) {
        file_put_contents($filename, "[LOG] " . $message . PHP_EOL, FILE_APPEND);
    }
}

class Application {
    use Logger, FileLogger;

    public function run() {
        $this->log("L'application a démarré.");
        $this->logToFile("app.log", "L'application a démarré.");
    }
}

$app = new Application();
$app->run();
// Affichera : [LOG] L'application a démarré.
// Écrira dans app.log : [LOG] L'application a démarré.
----


=== Explication :

=== Définition du trait Logger :

Le trait Logger contient une méthode log() qui affiche un message avec une balise [LOG].


Il peut être utilisé par toute classe souhaitant inclure cette fonctionnalité de journalisation.

=== Définition du trait FileLogger :

Le trait FileLogger contient une méthode logToFile() qui permet d'écrire un message dans un fichier.


=== Utilisation des traits dans la classe Application :

La classe Application utilise les deux traits (Logger et FileLogger) avec le mot-clé use. 

=== ...

Cela permet à la classe d'avoir accès aux méthodes log() et logToFile() sans avoir à hériter d'une classe spécifique.


=== Combiner plusieurs traits dans une classe :

Une classe peut utiliser plusieurs traits en les listant après le mot-clé use, séparés par des virgules.

=== Exemple :

[source, php]
----
trait TraitA {
    public function methodA() {
        echo "Méthode A du TraitA<br>";
    }
}

trait TraitB {
    public function methodB() {
        echo "Méthode B du TraitB<br>";
    }
}

class MaClasse {
    use TraitA, TraitB;
}

$obj = new MaClasse();
$obj->methodA(); // Affichera : Méthode A du TraitA
$obj->methodB(); // Affichera : Méthode B du TraitB
----


== Résolution de conflits avec des traits :

Si deux traits utilisés dans une même classe définissent des méthodes portant le même nom, cela provoquera un conflit. 

=== ...

PHP permet de résoudre ces conflits:
[%step]
* à l'aide du mot-clé **insteadof**, qui indique quel trait utiliser en priorité,
* en renvoyant une méthode sous un autre nom avec le mot-clé **as**.

=== Exemple de résolution de conflit :
[source, php]
----
trait TraitA {
    public function parler() {
        echo "Bonjour du TraitA<br>";
    }
}

trait TraitB {
    public function parler() {
        echo "Bonjour du TraitB<br>";
    }
}

class MaClasse {
    use TraitA, TraitB {
        TraitA::parler insteadof TraitB; // Utiliser la méthode parler du TraitA
        TraitB::parler as parlerDeB;     // Renommer la méthode parler du TraitB
    }
}

$obj = new MaClasse();
$obj->parler();       // Affichera : Bonjour du TraitA
$obj->parlerDeB();    // Affichera : Bonjour du TraitB
----


== Explication :

=== TraitA::parler insteadof TraitB : 

Cela indique que, en cas de conflit, on souhaite utiliser la méthode parler() du TraitA au lieu de celle du TraitB.

=== TraitB::parler as parlerDeB : 

Cela permet de renommer la méthode parler() du TraitB en parlerDeB, ce qui permet à la classe d'accéder aux deux méthodes.

=== Utilisation de méthodes abstraites dans les traits :

Les traits peuvent définir des méthodes abstraites, obligeant les classes qui les utilisent à implémenter ces méthodes. 

=== ...

C'est utile si le trait dépend de certaines méthodes qui doivent être définies dans la classe qui l'utilise.


=== Exemple de méthode abstraite dans un trait :
[source, php]
----
trait Identifiable {
    abstract public function getId();

    public function afficherId() {
        echo "L'ID est : " . $this->getId() . "<br>";
    }
}

class Utilisateur {
    use Identifiable;

    public function getId() {
        return 42;
    }
}

$user = new Utilisateur();
$user->afficherId(); // Affichera : L'ID est : 42
----


=== Explication :

Le trait Identifiable déclare une méthode abstraite getId(). 

=== ...

Toute classe qui utilise ce trait doit fournir une implémentation de getId().

=== ...

La méthode concrète afficherId() dans le trait dépend de la méthode getId() implémentée par la classe Utilisateur.

=== Traits et héritage :

Les traits peuvent être utilisés dans une hiérarchie de classes qui utilisent l'héritage. 

=== ...

Lorsqu'un trait est utilisé dans une classe, ses méthodes sont intégrées dans cette classe comme si elles faisaient partie de la classe elle-même.

=== Exemple d'utilisation de traits avec l'héritage :

[source, php]
----
trait Securite {
    public function verifierAcces() {
        echo "Accès vérifié.<br>";
    }
}

class Utilisateur {
    use Securite;

    public function connecter() {
        $this->verifierAcces();
        echo "Utilisateur connecté.<br>";
    }
}

class Admin extends Utilisateur {
    public function connecter() {
        $this->verifierAcces();
        echo "Administrateur connecté.<br>";
    }
}

$user = new Utilisateur();
$user->connecter(); // Affichera : Accès vérifié. Utilisateur connecté.

$admin = new Admin();
$admin->connecter(); // Affichera : Accès vérifié. Administrateur connecté.
----


=== Explication :

Le trait Securite est utilisé à la fois par la classe Utilisateur et la classe Admin. 

=== ...

Il contient la méthode verifierAcces() qui est partagée entre les deux classes.

=== ...

La méthode connecter() dans Admin redéfinit celle de Utilisateur, mais continue d'utiliser la méthode du trait Securite pour vérifier l'accès avant la connexion.


== Résumé des avantages des traits :

=== Réutilisation du code : 

Les traits permettent de partager des méthodes entre plusieurs classes sans utiliser l'héritage. 

=== ...

Cela permet de réutiliser du code sans les limitations de l'héritage simple.

=== Modularité : 

Ils permettent de découper le code en modules réutilisables, ce qui rend le code plus propre et plus facile à maintenir.

=== Évite les conflits d'héritage : 

Puisqu'en PHP, une classe ne peut hériter que d'une seule classe, les traits permettent d'éviter cette limitation en offrant une alternative flexible pour partager du code entre classes.

=== Résolution de conflits : 

En cas de conflit de noms entre des méthodes provenant de plusieurs traits, PHP fournit des mécanismes (comme insteadof et as) pour résoudre ces conflits proprement.

//--------------------------------------------------------------------


